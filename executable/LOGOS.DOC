####============================================================

	####λογοσ	：##リスプインタプリタ仕様説明書

		 LOGOS.out Version 0.50 1993/05/02
			 澤田高宏／《ぬえ》
			   NIFTY-PFE02147

####============================================================


			    +----------+
			    ! はじめに !
			    +----------+


##この処理系は go32 上で動作するリスプのインタプリタです。利用にあたっ
ては、３８６以上のＣＰＵで go32 が稼働する環境が必要です。また、添付
のコンパイラ ( テスト版 ) を利用する際にもインタプリタが必要です。
##グラフィック機能以外や go32 のバージョンに依存していない通常の関数
であれば、どの機種でも同じ様に使用できるはずです ( グラフィック関数
はＤＪＧＣＣのものしか使用していませんので、各機種用のライブラリをリ
ンクすればグラフィックも使用できるようになります )。
##このプログラムの中では、ＤＪＧＣＣのライブラリルーチンを一部利用し
ていますので、このプログラムの利用もＦＳＦの原則に則った形でお願いし
ます。また、このプログラムの使用により利用者が被った不都合、損害につ
いて作者は責任を負いかねます。
##したがって、このプログラムの改造は商用以外の目的であれば、いっさい
自由です。転載も自由ですが、メンテナンスについてはＮＩＦＴＹ−ＳＥＲ
ＶＥのＦＡＩ（人工知能フォーラム）のＦＡＩ−ＬＩＳＰプロジェクトの会
議室で行わせて戴きます。

##なお、このドキュメントはλογοσ本体から呼び出されるヘルプファイ
ルを兼ねています。


		 #####+----------------------+
		 #####!#λογοσの作成方針 !
		 #####+----------------------+


##このλογοσ（ＬＯＧＯＳ（ロゴス）：論理、言葉を意味するギリシャ
語）はリスプのインタープリタです。すでに、世の中には各種の優れたリス
プ言語処理系が存在し、また、中にはＸＬＩＳＰなどのソースプログラムの
公開されたものもあります。そうした中で、敢えてこの処理系を作ろうとし
た理由は次のようなものです。

	１．ふんだんにメモリを利用したい
	２．できるだけ速いリスプ処理系がほしい
	３．言語処理に向いた機能を実現したい

##作者は自然言語処理のプログラムの作成を最終目標に置いていますので、
旧来のＭＳ−ＤＯＳやウインドウズ上ではのメモリ上の制約が大きな問題と
なります。この点、go32 という優れたＤＯＳエクステンダの利用により大
量のメモリを確保することができるようになりました。
##また、処理速度ということから考えますと、Ｃで処理系を作成することは
インプリメントが容易であるなどの利点も大きいものの、機械に密着したコー
ディングで速度の改善を図ることには一定の限界があるといわざるを得ませ
ん。このことから、私はλογοσを go32 用のアセンブラａｓによって記
述しました（なお、もともとａｓはＣのための専用アセンブラですから、プ
リプロセッサｃｐｐも利用しています）。

##ここで、どういう機能を実現するかという問題があるわけですが、作者と
しては次のような基準で考えたいと思っています。

	１．できるかぎり、文法、仕様についてはコモンリスプ（第２版）
	に近づける
	２．ただし、使用頻度が低く、かつ高速化をはばむような機能につ
	いては、敢えて取り入れない
	３．また、コモンリスプでは定義されていない関数でも、処理上便
	利であり高速な処理ができるものは美学的感覚に反しても取り入れ
	る

##例えば、コモンリスプの関数定義における &OPTION 以下の構文を取入れ
ないというようなことです。それに伴う不便は、処理系のソースを公開する
ことにより、利用者が追加するか、コンパイラによって補うという考え方を
取っています。

  実際のところ、現状のλογοσ処理系では上記の目標にまだまだ遠く及
んでいませんが、利用者の便宜にかなうようソースプログラムのすべてを公
開し、商用目的以外の改造であればいっさい自由としますので、改良案等提
示していただければ幸いです。


			+------------------+
			!#λογοσの起動 !
			+------------------+


##λογοσの起動方法は次の通りです。もちろん debug32 や stub を利
用した起動も可能です。 init.lsp と logos.doc、logos.err をとりあえず
カレントディレクトリにおいて、

	go32	logos.out -[option] filename
	debug32 logos.out -[option] filename

##または、

	copy /b stub.exe+logos.out logos.exe としたのち、
	logos -[option] filename

##とすれば、プロンプトが出て、入力待ちになります。
##起動時のオプションスイッチには以下のようなものがあります（前回のバー
ジョンから変更されています）。

	-m1###: 開始メッセージを表示する（デフォルト）
	-m0###: 開始メッセージを表示しない
	-a1###: メモリの取得状況を表示する（デフォルト）
	-a0###: メモリの取得状況を表示しない
	-l1###: 'init.lsp' を自動的に読み込む（デフォルト）
	-l0###: 'init.lsp' を自動的に読み込まない
	-?####: オプションスイッチ一覧を表示する
	-o[n] : コンパイルされたコードの領域をｎキロバイト確保する
	-c[n] : コンス領域をｎキロバイト確保する
	-v[n] : 配列（ベクタ）領域をｎキロバイト確保する
	-t[n] : 構造体領域をｎキロバイト確保する
	-s[n] : シンボル領域をｎキロバイト確保する
	-f[n] : 浮動小数点数領域をｎキロバイト確保する
	-g[n] : 文字列領域をｎキロバイト確保する
	-k[n] : スタック領域をｎキロバイト確保する

##また、オプションの後ろにファイル名を付けると、そのファイルが自動的
に読み込まれます。

  間違ったオプションを指定すると次のような画面になり、オプションが確
認できます。

【実行例】

:B:\LOGOS\go32\go32 logos.out -x a:/djgcc/bin/go32.exe Copyright (C)
:1991 DJ Delorie
:
:invalid option switch#: -x
:
:Usage#: go32 logos.out -[option][flag] filename
:
:###-m[f] : display opening-Message#or not (default : display)
:###-a[f] : display memory Allocation or not (default : display)
:###-l[f] : load 'init.lsp' automatically or not (default : read)
:###-?	 #: display option switches
:###if the figure following an option is 1, LOGOS lets the option
:work.
:###otherwise, LOGOS will not do.
:
:###-o[n] : get memory for compiled Object codes area
:###-c[n] : get memory for Cons area
:###-v[n] : get memory for array and Vector area
:###-t[n] : get memory for strucT area
:###-s[n] : get memory for Symbol area
:###-f[n] : get memory for Floanum area
:###-g[n] : get memory for strinG area
:###-k[n] : get memory for stacK area
:###[n]s mean the amount of the memory measured by unit of Kbytes
:
:###<Example> go32 logos.out -l1#-m0#-A1#-c10000#-s5000#comp.lsp


		###+----------------------------+
		###!#λογοσのメモリ割り付け !
		###+----------------------------+


##(#この項目は読まずに飛ばしてもかまいません )

##ここではλογοσのメモリ確保について、簡単に説明しておきます。せっ
かくエクステンダを使っているわけですから、ふんだんにメモリが利用でき
るようになっているのですが、あまりに大量のメモリを使用しようとすると
ハードディスクを利用した仮想メモリに依存することになり、ガーベジコレ
クション（ゴミ集め）の際などに動作速度がかなり遅くなる可能性がありま
す。このため、実装してあるメモリの量に比べて、あまり極端に多いメモリ
を確保するのはお勧めできません。

  現在のバージョンでは、各領域について６４キロバイト以下しか確保しな
いような指定がなされても、自動的に６４キロバイト確保するようになって
います。

  -o で確保されるコンパイルされたコードの領域とは、コンパイラがコン
パイルしたユーザープログラムが格納される領域です。従って、コンパイラ
を使いこなすのにつれ、大きな領域が必要となっていきますが、現時点では
意識する必要はありません。

  -c で確保されるコンス領域は、リスト構造が保存されている領域です。
ここは最優先で確保してよいと思いますが、仮想メモリのアクセス速度を実
感しながら決めてみて下さい。なお、１つのコンスの大きさは８バイトです
から、-c8000#と指定すると、８メガバイトを確保し、１メガセルが使用で
きるようになります）。

##-v では配列（現状ではベクタ）の領域が確保され、-t では構造体の領域
が、-g では文字列の領域が、-f では浮動小数点数の領域が確保されます。
これらの領域の大きさは、使用するプログラムでそれぞれのデータをどれく
らい使うかで決めればよいでしょう。

##以上のコンス、配列、構造体、文字列、浮動小数点数については、ガーベ
ジコレクタ（使わなくなったデータを回収し、再利用できるようにする機能）
によって、データの再利用ができるほか、λογοσにはデータ領域が満杯
になると、データ領域を自動的に拡張する機能が備えてあるため、神経を使
う必要はありません。

  一方、一度データ領域の大きさを決めてしまうと後で変更できないのが、
シンボルアトムとスタックの領域です。-s で確保されるシンボルアトムの
領域は、それほど速度には影響しないところですので、特に言語処理などで
内部的にシンボルの生成を行うようなプログラムを使う場合は大目に確保す
ることをお勧めします。

  -b で確保されるスタック領域は、できるだけ大量に確保しておくことを
お勧めします。スタック領域を大量に確保しても、実行速度への影響は限ら
れますし、スタックのオーバーフローにあう可能性も低くなります。λογ
οσでは大量のスタックが確保できることから、速度を重視し、スタックの
あふれをチェックしていません。したがって、スタックを消費するような無
限ループではスタックのあふれによるエラー (go32 のエラー ) が出ること
もあります。go32 がエラーを出してλογοσが異常終了したときには、
まずスタックの指定を変えてみて下さい。


		###+----------------------------+
		###!#λογοσのコマンドループ !
		###+----------------------------+


##λογοσインタープリタは起動されるときに、ＸＬＩＳＰと違いワーク
スペースをロードしません。従って起動時にはいつもワークスペースは初期
化されます。
  次にλογοσは内部の時計を初期化し、続いて自動的に (load 'init.lsp)
を行い、カレントディレクトリーから "init.lsp" を読み込んで、その内容
を実行します（"init.lsp" の中には複数のプログラムを羅列することがで
きます。なお、λογοσではファイル名の拡張子は省略できません。）続
いて#λογοσは次のようなプロンプトを表示します。

【実行例】

:B:\LOGOS\GO32\go32 logos.out
:a:/djgcc/bin/go32.exe version 1.07L Copyright (C) 1991 DJ Delorie
:
:###LOGOS : LISP Interpreter Ver0.50 / Mar  1 1993
:
:LOGOS kernel area###: #x00001020-#x00010E94 (65140 bytes)
:kernel data area####: #x00400000-#x0040734C (29516 bytes)
:work area#for gbc###: #x0053C004-#x0063C004 (1048576 bytes)
:stack area	#####: #x00681004-#x00701004 (524288 bytes)
:compiled code area##: #x0042A004-#x0043A004 (65536/65536 bytes)
:cons area	#####: #x0043B004-#x0053B004 (1048576/1048576 bytes)
:symbol atom area####: #x00409004-#x00429004 (112743/131072 bytes)
:array & vector area#: #x0063D004-#x0064D004 (65536/65536 bytes)
:struct area	#####: #x0064E004-#x0065E004 (65536/65536 bytes)
:string atom area####: #x0065F004-#x0066F004 (65536/65536 bytes)
:float number area###: #x00670004-#x00680004 (65536/65536 bytes)
:
:ok
:<0>》

##これは#λογοσが式の入力を待っているという表示で、<0>#というの
は括弧の現在の深さを示しています。このプロンプトは変更が可能です
（"init.lsp" の中で定義してあります）。

##式の入力が行われると、λογοσはその式を評価しにかかります。そし
て正常に評価が行われた場合には、その値をプリントして先のプロンプト表
示に戻り次の式の入力を待ちます。

  また、コンソールからの入力はシンボルアトム *redo-list* に蓄えられ、
関数 redo で参照することが可能です。他のリスプ同様、以下のシステム変
数も使えます。

	+###１回前の入力式
	++##２回前の入力式
	+++ ３回前の入力式
	-###評価中の式自身
	*###１回前の評価結果
	**##２回前の評価結果
	*** ３回前の評価結果


			#+----------------+
			#!#エバリュエータ !
			#+----------------+


##文字列、文字、整数はそれら自身が評価値になります。シンボルは変数と
して振舞い、現在の束縛状態から関連する値を取り出し、それを評価値とし
ます。

  リストは第１要素の値により、以下の手順で評価が行われます。

	・シンボルであればそのシンボルが束縛している関数を取り出しま
	す。
	・組込関数 subr、fsubr である場合には、それら自身を関数とし
	ます。
	・ユーザーによって定義された関数 expr, fexpr, macro である場
	合には、関数に展開します。
	・高階関数の形になっていれば、関数に展開します。
	・上記以外はエラーとなります。
	・上記ステップで生成された関数を使って値を動的に評価します。
	・subr の場合はリストの残りを評価した後、該当の subr にそれ
	らの値を引数として渡して評価を行います。引数が数の定義よりも
	少ない数しかない場合は、nil が与えられます。
	・fsubr の場合にはリストの残りをそのまま fsubr に引数として
	渡して評価を行います。
	・expr の場合はリストの残りを評価した後、該当の expr にそれ
	らの値を引数として渡して評価を行います。引数が関数の定義より
	も少ない数しかない場合は、nil が与えられます。
	・fexpr の場合にはリストの残りをそのまま fexpr に引数として
	渡して評価を行います。
	・macro の場合にはリストの残りを評価したあと、再度評価を行い
	ます。

  なお、クロージャ、ラベルはサポートしていません。


			#####+--------+
			#####!#エラー !
			#####+--------+


##λογοσインタープリタが式の評価途中でエラーを検出した場合、エラー
メッセージを表示しますが、ＸＬＩＳＰのようなブレークコマンドループは
備えられていません。このエラーメッセージそのものは別のファイルに記述
されていますので、メッセージの書き換えが可能です。

  エラーを起こした関数が推測可能な場合には、エラーメッセージと同時に
その関数名が表示されます。ただし、表示された関数がエラーを起こした関
数とは違う名前で同じ機能の関数の場合もあります。関数名に続いて、引数
が表示されることもあります。

##λογοσでは大量のスタックが確保できることから、速度を重視し、ス
タックのあふれをチェックしていません。したがって、スタックを消費する
ような無限ループではスタックのあふれによるエラー (go32 のエラー ) が
出ることもあります。この場合、次のようなメッセージが出て、λογοσ
の実行が止まります ( 実際に表示されるアドレスは当然異なっていると思
います )。

:Segmentation violation in pointer 0x00705000 at 40:9e67
:Exception 14 (0xe) at eip=9e67

##このように go32 がエラーを出してλογοσが異常終了したときには、
まず起動オプションのスタックのサイズ指定を大きくしてみて下さい。


			####+----------+
			####!#データ型 !
			####+----------+


##λογοσでは以下のデータ型を使用することができます。

	o リスト
	####スーパー括弧は使用できません。

	o シンボル
	####全角文字が使えます。エスケープ文字を使い、\n,\r,\t,\a,\e
	が利用できます。アトムの初期値は unk（未定義）です。数値列の
	途中で基数に反した文字があるものもシンボルとみなします。

	o 文字列
	####ダブルクォーテーションマークに囲まれた文字列で表現されま
	す。全角文字が使えます。エスケープ文字を使い、\n,\r,\t,\a,\e
	が利用できます。１次元配列として扱うことはできません。

	o 文字
	#####\ に続く１バイト文字もしくは全角文字で表現します。#
	\Backspace など、コモンリスプに準じた表記も利用できます。文
	字属性はありません。

	o 整数
	####２進数から３６進数の範囲で記述された数値で、-2^23 〜 2^
	23-1 の整数が利用できます。

	o 浮動小数点数
	####３２ビットショート実数（指数部８ビット、仮数部２３ビット）
	をサポートしています。範囲は± 3.39*10^38、精度は± 1.18*10^
	-38 です（精度はもっと悪いかもしれません）。浮動小数点演算プ
	ロセッサが装備されていない場合には、エミュレータが必要です。
	エミュレータさえあれば、sin、log、exp なども計算できます。浮
	動小数点演算プロセッサが装備されている場合には、エミュレータ
	とは別の専用ルーチンを使いますので、演算速度はずっと速くなり
	ます。なお、浮動小数点数の入出力では、基数は常に１０進数とな
	ります。

	o ベクタ
	#####( .... ) で表現されます。例###(0 1 2 3)

	o 構造体
	#####S( 構造体名#スロット名#スロット内容 .... ) で表現されま
	す。read 関数から直接読み込むことはできません。
	例###S(ship x 100 y 200)

	o lambda
	####ラムダ式。複数の本体を持つことができます。

	o subr
	####組み込み関数。

	o fsubr
	####特殊形式。

	o expr
	####引数をすべて評価するユーザー定義関数で、複数の本体を持つ
	ことができます（暗黙の progn）。&rest キーワードにより、不定
	数の引数を取ることもできます。
	例##(defun plus (x &rest y)(apply #'+ x y))
	####(plus 1 2 3 4 5) → 15

	o fexpr
	####引数を評価しないユーザー定義関数で、複数の本体を持つこと
	ができます（暗黙の progn）。常に引数は１つのみです。

	o macro
	####ユーザー定義マクロ関数。&rest キーワードにより、不定数の
	引数を取ることもできます。

##現状、以下のデータ型は使用できません。

	o ストリーム
	o 複素数
	o 多倍長整数
	o 分数
	o オブジェクト
	o 多次元配列
	o クロージャ


			####+----------+
			####!#構文規則 !
			####+----------+


##λογοσのコメントはセミコロンで始まって行末で終了します。行終端
は #\Return,#\Linefeed の２文字からなっています。

##シンボル名として大文字小文字の区別は行われません。全ての大文字は入
力された時点で小文字に変換されます。

##λογοσでのシンボル名および文字列はマクロ文字（( ) ' ` , " ;）
以外の文字の連なりで構成されます。ただし、エスケープ文字 '\' を使用
すれば、マクロ文字も使用できます。

  エスケープ文字による表現として、以下のようなものも可能です。

	\\  文字 '\' を表す。
	\n  改行コードを表す。
	\r  復帰コードを表す。
	\t##タブコードを表す。
	\a##ベルコードを表す。
	\e##ＤＯＳのエスケープコードを表す。

##ただし、次の表現は使用できません。

:	マルチプルエスケープ表現
:	\f##フォームフィードを表す。
:	\nnn	８進数表現が nnn の文字を表す。

##整数は数字の連なりで構成され、*read-base* の値を基数として、入出力
が行われます。#b,#o,#x を使った表現も可能です。#b などを使った表現で
は符号は #b などの後に付けて下さい（#x-98 は数値として正しいが、-#x98
はただのシンボルアトムとなる）。
##ただし、浮動小数点数の入出力では、基数は常に１０進数となります。

	#b #２進数表記（０−１）
	####例	#b0010	####→ 2
	#o##８進数表記（０−７）
	####例	#o-010	####→ -8
	#x  １６進数表記（０−９、Ａ−Ｆ）
	####例	#d-010	####→ -16

  リードマクロとして次の機能が使用できます
	'###クォートの略記
	####例	'(A)####→ (quote (A))
	#'##ファンクションの略記
	####例	#'(A)###→ (function (A))
	#.##読み込み時評価
	####（*read-eval* が nil の場合はエラーになります）
	####例	'(1 2 3 #.(1+ 3)) → (1 2 3 4)
	;###コメント
	#0  強制終了 (exit) と同じ

##文字型では次のような表現が可能です

	#\Bell	####07h
	#\Backspace 08h
	#\DosEscape 1bh'
	#\Escape ###'\'
	#\Linefeed  0ah
	#\Newline####\Linefeed と同じ
	#\Page	####0ch
	#\Return####0dh
	#\Rubout#####\backspace と同じ
	#\Space  ###' '
	#\Tab	####09h

##現在以下のリードマクロはサポートされていません

:	#\<char>####<char>#のアスキー値
:	#| ... |#	コメント
:	#:<symbol>	インターンされないシンボル
:	#c	複素数
:	#nnRddd  ###任意の基数による数値


			##+--------------+
			##!#システム変数 !
			##+--------------+

	*prompt*
	####プロンプトとして利用するアトム
	####例	(setq *prompt* '->) *read-base*
	####読み込み時の基数（初期値は１０）*print-base*
	####表示時の基数（初期値は１０）

	*print-radix*
	####表示時に基数を明示するかどうかのフラグ（初期値は nil）
	####例	(setq *print-radix* t)
		10. #xef #b-10110 #12r1a

	*paren-counter*
	####括弧数を表示するかどうかのフラグ（初期値は t）

	*print-paren*
	####括弧を表示するかどうかのフラグ（初期値は t）

	*print-level*
	####表示する括弧の深さを指定する（初期値は nil）

	*print-length*
	####Ｓ式や配列、構造体の表示する要素の数を指定する（初期値は
	nil）

	*print-pretty*
	####quote の略記を行うかどうかのフラグ（初期値は t）

	*print-array*
	####配列の内容を表示するかどうかのフラグ（初期値は nil）

	*print-escape*
	####文字列の (") や文字型の (#\) を表示するかどうかのフラグ
	（初期値は t）

	*print-fixnum-format*
	####整数の表示形式（表示基数が１０進数の時のみ有効）
	####Ｃの printf 関数のフォーマットと同じ
	####例	(setq *print-fixnum-format* "%+8d")
		(setq *print-fixnum-format* "%-4U")

	*print-floanum-format*
	####浮動小数点数の表示形式
	####Ｃの printf 関数のフォーマットと同じ
	####例	(setq *print-floanum-format* "%#.8g")
		(setq *print-floanum-format* "%+10f")

	*input-echo*
	####ファイル読込時に表示するかどうかのフラグ（初期値は nil）

	*gc-flag*
	####ガーベッジコレクト時のメッセージ制御（初期値は nil）

	*gc-mesage*
	####ガーベジコレクタ起動時のメッセージ（初期値は nil）

	*gc-counter*
	####ガーベッジコレクタ起動回数（初期値は 0）

	*print-case*
	####シンボルアトムの表示モード
	####値が :upcase ならば大文字、:downcase ならば小文字、:
	capitalize であれば１文字目のみ大文字

	*read-eval*
	####リードマクロ #. を有効にするかどうかのフラグ（初期値は
	t）

	*console-mode*
	####入力モードの設定 ( 初期値は nil）
	####t ならばバッファードキー入力とし、ＴＳＲの力を借りれば、
	ヒストリ入力ができるようになる。ただし、go32 と相性の悪いＴ
	ＳＲも少なくないようなので要注意。

	*car-of-nil*
	####nil の car を取得できるようにするかどうかのフラグ（初期
	値 t）

	*trace-function-message*
	####評価するＳ式についてのトレースメッセージ

	*trace-argments-message*
	####引数についてのトレースメッセージ

	*trace-result-message*
	####返り値についてのトレースメッセージ

	*load-print*
	####*load-print* が nil でなければ、load 関数の処理の際にファ
	イル中の内容を評価した結果を表示し、*load-print* の内容を区
	切りとして表示します

	*manual-file*
	####マニュアル参照関数 (describe) で参照するマニュアル

	*error-header*
	####エラー表示の接頭詞

	*error-message-file*
	####エラーメッセージファイルの指定

	*reg-start-byte-position*
	####文字列検索関数 (string-match) による文字列検索で一致した
	位置（バイト単位）

	*reg-end-byte-position*
	####文字列検索関数 (string-match) による文字列検索で一致した
	文字列の次の位置（バイト単位）


			###+------------+
			###!#関数の仕様 !
			###+------------+


  ここから先は、λογοσ組み込み関数のリファレンスマニュアルです。
関数の掲載順序は、原則としてコモンリスプ第２版で相当する関数の順番に
従うように並べてみました。以下の章番号は同書の章番号を指しています。
コモンリスプにはない関数については、最も関連が強いと思われる章にまと
めてあります。


  ###［第４章 型指定子］
  ###-------------------


coerce <object> <result-type>
	##組込関数 (p.54 ltype.p)
	  機能 型変換を行う。変換可能な組み合わせは下のとおり。
	#######・コンスからベクタ、文字列、構造体、シンボル、文字
	#######・ベクタからコンス、文字列、構造体、シンボル、文字
	#######・文字列からコンス、ベクタ、シンボル、文字
	#######・構造体からコンス、ベクタ、シンボル、文字
	#######・シンボルからコンス、ベクタ、文字列、文字
	#######・文字から整数、文字列、シンボル
	#######・整数から浮動小数点数
	#######・浮動小数点数から整数
	#######<result-type> に指定する型は以下の通り。
	#######・シンボル#####symbol
	#######・文字型#######character
	#######・文字列型#####string
	#######・コンスセル###cons
	#######・配列 ( ベクタ ) array
	#######・構造体#######struct
	#######・整数	######fixnum
	#######・浮動小数点型#floanum
	##値 ##変換された値
	##備考 副型等はサポートしていない。
	#######シンボルアトムや文字列に変換する時は、元の引数の要素
	#######が全て文字でなくてはなりません。
	#######構造体に変換する時は、引き数の要素が全てシンボルでな
	#######くてはなりません。
	#######文字に変換する時は引数の要素の一文字目のみが対象とな
	#######ります。
	#######数値や文字以外を整数に変換すると、アドレスを返します。

type-of <object>
	##組込関数 (p.56 ltype.p)
	  機能 式のデータタイプを返す
	##値 ##［引数］#######［値］
	#######nil		nil
	#######シンボル 	symbol
	#######コンスセル	cons
	#######配列（ベクタ）	array
	#######構造体型####### （構造体型名）
	#######組込関数 	subr
	#######特殊形式 	fsubr
	#######ＥＸＰＲ型関数	expr
	#######ＦＥＸＰＲ型関数 fexpr
	#######ＭＡＣＲＯ型関数 macro
	#######整数		fixnum
	#######浮動小数点型	floanum
	#######文字型		character
	#######文字列型#	string
	##備考 副型等はサポートしていない
	##例###(type-of 'type-of) → subr


  ###［第５章 プログラムの構造］
  ###---------------------------


defun <name> <lambda-list> {form}
	##特殊形式 (p.72 leval.p)
	  機能 関数を定義する
	#######（暗黙の progn になっており、複数の本体が定義できる）
	##値 ##関数名
	##備考 defun,def,de は全て同じ
	##例###(de  ncons (x) (cons x#nil))
	  #####(defun va (x . y)(cons y x))
		####; ２番目以降の引数が y に渡される
	#######(defun va (x &rest y)(cons y x))
		####; 上と同じ

def###<name> <lambda-list> {form}
	##特殊形式 (leval.p)
	  備考 defun を参照のこと

de####<name> <lambda-list> {form}
	##特殊形式 (leval.p)
	  備考 defun を参照のこと

df####<name> <lambda-list> {form}
	##特殊形式 (leval.p)
	  機能 ＦＥＸＰＲ型関数を定義する
	#######ＦＥＸＰＲ型関数では引数をひとつだけリストとして取る。
	#######また、その引数は評価されない。
	#######（暗黙の progn になっており、複数の本体が定義できる）
	##値 ##関数名

movd <function> <symbol>
	##組込関数 (leval.p)
	  機能 関数定義をコピーする
	#######<function>  もととなる関数定義を持つシンボルアトム
	#######<symbol>####定義を移されるシンボルアトム
	##値 ##新しく定義を与えられたシンボル

defvar	  <name> [initial-value [documentation]]
	##特殊形式 (p.73 leval.p)
	  機能 スペシャル変数の宣言を行う。
	#######この宣言を行うと、それ以降ずっとスペシャル変数となり、
	#######定数として使うことはできない。
	#######<name> のアトムの値は初期値 <initial-value> に変更さ
	#######れる。
	##値 ##<name> と初期値 <initial-valu> をつなげたリストを返す。
	##備考 <initial-value> が省略されると、コモンリスプの場合で
	#######は初期化がなされないが、ここでは#nil で初期化される。
	#######<documentation> はソースプログラムの注釈にしかならな
	#######い。

defparameter ##<name> [initial-value [documentation]]
	##特殊形式 (p.73 leval.p)
	  機能 この宣言では#<name> のアトムの値は初期値 <initial-value
	#######>
	#######に変更されるだけであり、後にスペシャル変数や定数の宣
	#######言をすることもできる。
	##値 ##<name> と初期値 <initial-valu> をつなげたリストを返す。
	##備考 <initial-value> が省略されると、コモンリスプの場合で
	#######はエラーだが、ここでは#nil で初期化される。
	#######<documentation> はソースプログラムの注釈にしかならな
	#######い。

defconstant####<name> [initial-value [documentation]]
	##特殊形式 (p.73 leval.p)
	  機能 定数の宣言を行う。この宣言を行うと、<name> のアトムの
	#######値
	#######は初期値 <initial-value> となり、それ以降ずっと定数と
	#######なり、スペシャル変数として使ったり、値を変えたりする
	#######ことはできなくなる。
	##値 ##<name> と初期値 <initial-valu> をつなげたリストを返す。
	##備考 <initial-value> が省略されると、コモンリスプの場合で
	#######はエラーだが、ここでは#nil で初期化される。
	#######<documentation> はソースプログラムの注釈にしかならな
	#######い。


  ###［６章 述語］
  ###-------------


typep <object> <type>
	##組込関数 (p.83 lpred.p)
	  機能 式のデータ型が指定された型か
	#######<object>  データ型を調べる式
	#######<type>	######以下のシンボルのいずれか
		####symbol	###シンボル
		####cons #####コンスセル
		####array	###配列（ベクタ）
		####（構造体型名）#構造体
		####subr######組込関数
		####fsubr	###特殊形式
		####expr######ＥＸＰＲ型関数
		####fexpr	###ＦＥＸＰＲ型関数
		####macro	###ＭＡＣＲＯ型関数
		####string	###文字列型
		####fixnum	###整数型
		####floanum	###浮動小数点型
		####character#文字型
	##備考 副型等はサポートしていない
	##値 ##正しければ t、偽なら#nil
	##例###(typep '"abcd" 'string) → t

null <object>
	##組込関数 (p.86 lpred.p)
	  機能 空リスト（nil,()）か？
	##値 ##空リストならば t それ以外は#nil

symbolp <objext>
	##組込関数 (p.86 lpred.p)
	  機能 シンボル（nil を含む）か？
	##値 ##シンボルならば t それ以外は#nil

atom <object>
	##組込関数 (p.86 lpred.p)
	  機能 アトムか？
	##値 ##アトムならば t それ以外は#nil

consp <object>
	##組込関数 (p.86 lpred.p)
	  機能 コンスか？
	##値 ##コンスセルならば t それ以外は#nil

listp <object>
	##組込関数 (p.86 lpred.p)
	  機能 リストか？
	##値 ##コンスセルまたは#nil ならば t それ以外は#nil

nlistp <object>
	##組込関数 (p.86 lpred.p)
	  機能 リストでないか？
	##値 ##コンスセルまたは#nil ならば nil それ以外は#t

numberp <object>
	##組込関数 (p.86 lpred.p)
	  機能 数値（整数型および浮動小数点型）か？
	##値 ##数値ならば t それ以外は#nil

integerp <objext>
	##組込関数 (p.86 lpred.p)
	  機能 整数か？
	##値 ##整数ならば t それ以外は#nil

rationalp <objext>
	##組込関数 (p.87 lpred.p)
	  機能 有理数か？
	##備考 現状、integerp と同じ
	##値 ##有理数ならば t それ以外は#nil

floatp <object>
	##組込関数 (p.87 lpred.p)
	  機能 浮動小数点数か？
	##値 ##浮動小数点数ならば t それ以外は#nil

realp <object>
	##組込関数 (p.87 lpred.p)
	  機能 実数か？
	##備考 現状、numberp と同じ
	##値 ##実数ならば t それ以外は#nil

complexp <object>
	##組込関数 (p.87 lpred.p)
	  機能 複素数（未実装）か？
	##備考 常に#nil を返す
	##値 ##複素数ならば t それ以外は#nil

characterp <object>
	##組込関数 (p.87 lpred.p)
	  機能 文字か？
	##値 ##文字ならば t それ以外は#nil

stringp <object>
	##組込関数 (p.87 lpred.p)
	  機能 文字列か？
	##値 ##文字列ならば t それ以外は#nil

bit-vector-p <object>
	##組込関数 (p.87 lpred.p)
	  機能 ビットベクタか？
	##備考 常に#nil を返す
	##値 ##ビットベクタならば t それ以外は#nil

vectorp <object>
	##組込関数 (p.88 lpred.p)
	  機能 ベクタか？
	##値 ##ベクタならば t それ以外は#nil

single-vector-p <object>
	##組込関数 (p.88 lpred.p)
	  機能 単純ベクタか？
	##値 ##単純ベクタならば t それ以外は#nil

single-string-p <object>
	##組込関数 (p.88 lpred.p)
	  機能 単純文字列か？
	##備考 stringp と同じ
	##値 ##単純文字列ならば t それ以外は#nil

single-bit-vector-p <object>
	##組込関数 (p.88 lpred.p)
	  機能 単純ビットベクタか？
	##備考 常に#nil を返す
	##値 ##単純ビットベクタならば t それ以外は#nil

arrayp <object>
	##組込関数 (p.88 lpred.p)
	  機能 配列か？
	##備考 現状 vectorp に同じ
	##値 ##配列ならば t それ以外は#nil

structp <object>
	##組込関数 (p.88 lpred.p)
	  機能 構造体か？
	##値 ##構造体ならば t それ以外は#nil

packagep <object>
	##組込関数 (p.88 lpred.p)
	  機能 パッケージか？
	##備考 現状常に#nil を返す
	##値 ##パッケージならば t それ以外は#nil

objectp <expr>
	##組込関数 (lpred.p)
	  機能 オブジェクトか？
	##備考 現状常に#nil を返す
	##値 ##オブジェクトならば t それ以外は#nil

streamp <expr>
	##組込関数 (lpred.p)
	  機能 ストリームか？
	##備考 現状常に#nil を返す
	##値 ##ストリームならば t それ以外は#nil

functionp <object>
	##組込関数 (p.88 lpred.p)
	  機能 関数か？
	##備考 fsubr,fexpr,macro は#nil
	##値 ##関数及びラムダ式なら#t それ以外は#nil

subrp <object>
	##組込関数 (p.88)
	  機能 組込関数 (subr) か？
	##値 ##組込関数なら#t それ以外は#nil

compiled-function-p <object>
	##組込関数 (p.89 lpred.p)
	  機能 コンパイルされた関数か？
	##値 ##コンパイルされた関数なら#t それ以外は#nil

laterp <expr1> <expr2>
	##機能 シンボルアトムの登録時期比較
	##値 ##expr1,2 がシンボルであれば、expr1 が#expr2 よりあとに
	  #####登録されたものであれば、t そうでなければ nil

eq <x> <y>
	##組込関数 (p.89 lpred.p)
	  機能 式 x と y が全く同一か？（ポインタで比較する）
	##備考 シンボル、文字、整数は、この関数で同定できる
	##値 ##全く同一ならば t それ以外は#nil

neq <x> <y>
	##組込関数 (lpred.p)
	  機能 式が全く同一ではないか？（ポインタで比較する）
	##備考 (not (eq x y)) に同じ
	#######シンボル、文字、整数は、この関数で同定できる
	##値 ##全く同一ならば nil それ以外は#t

eql <x> <y>
	##組込関数 (p.91 lpred.p)
	  機能 式 x と y が全く同一か？（ポインタで比較する）
	##備考 eq に浮動小数点数比較を加えたもの
	#######数の値が同一ならば t を返します
	##値 ##全く同一ならば t それ以外は#nil

neql <x> <y>
	##組込関数 (lpred.p)
	  機能 式が全く同一ではないか？
	##備考 (not (eql x y)) に同じ
	#######neq に浮動小数点数比較を加えたもの
	#######数の値が同一ならば nil を返します
	##値 ##全く同一ならば nil それ以外は#t

equal <x> <y>
	##組込関数 (p.92 lpred.p)
	  機能 式は等しいか？
	##備考 文字列比較は string= 関数と同じ
	##値 ##同一ならば t それ以外は#nil

nequal <x> <y>
	##組込関数 (lpred.p)
	  機能 式は等しいくないか？
	##備考 (not (equal x y)) に同じ
	##値 ##同一ならば nil それ以外は#t

equalp <x> <y>
	##組込関数 (p.93 lpred.p)
	  機能 式は等しいか？
	##備考 文字列比較は string-equal 関数と同じ
	#######文字比較は char-equal 関数と同じ
	#######（半角アルファベットの大文字小文字を全て同一視、ただ
	#######し、全角文字の大文字小文字は同一視しない）
	##値 ##同一ならば t それ以外は#nil

nequalp <x> <y>
	##組込関数 (lpred.p)
	  機能 式は等しいくないか？
	##備考 (not (equalp x y)) に同じ
	##値 ##同一ならば nil それ以外は#t

not <object>
	##組込関数 (p.95 lpred.p)
	  機能 偽か？
	##値 ##nil ならば t それ以外は#nil

and {form}
	##特殊形式 (p.95 lpred.p)
	  機能 式の論理積
	#######{form}	 論理積をとる式のリスト
	##値 ##{form} の中のいずれかの式が#nil となったならば nil そ
	#######れ以外は最後の式の値 ,
	#######（式の実行はいずれかの式が#nil となった時点で停止する）
	##例###(and) → t #(and 1 2) → 2

or {form}
	##特殊形式 (p.95 lpred.p)
	  機能 式の論理和
	#######{form}	 論理和をとる式のリスト
	##値 ##{form} の中のすべての式が#nil となったならば nil それ
	#######以外は最初に非#nil となった式の値
	#######（式の実行はいずれかの式が非#nil となった時点で停止す
	#######る）
	##例###(or) → nil (or 1 2) → 1


#####［第７章 制御構造］
#####-------------------


quote <object>
	##特殊形式 (p.98 llist.p)
	  機能 式を評価せずに返す
	##値 ##評価されていない <object>

kwote <object>
	##組込関数 (lread.p)
	  機能 式を評価してから#quote する
	##値 ##(quote) と式 <object> の値を cons#したもの
	##例###(kwote 'a)##→##(quote a)

function <fn>
	##特殊形式 (p.99 llist.p)
	  機能 式を関数に翻訳する（実態は quote と同じ）
	##値 ##翻訳された値
	##備考 #' の略記ができます
	##例###(function cons)
	  ######'cons

symbol-value <symbol>
	##組込関数 (p.102 lcont.p)
	  機能 シンボルの値取得
	##備考 大域的な値のみを扱います
	##値 ##シンボルの値
	#######値がないときはエラー

symbol-function <symbol>
	##組込関数 (p.102 lcont.p)
	  機能 シンボル関数値の取得
	##備考 大域的な定義のみを扱います
	#######局所定義がなされていれば、それが参照されます
	##値 ##シンボルの関数定義
	#######ユーザー定義関数の場合、値の car が引数、cadr#以降が
	#######本体
	#######組込関数の場合、処理アドレス

symbol-args <symbol>
	##組込関数 (lcont.p)
	  機能 シンボル関数の引数を取得
	##値 ##ユーザー定義関数の場合、仮引数リスト
	#######組込関数の場合、引数の最大数
	#######組込関数の引数が不定の場合は−１
	  #####特殊形式は０
	##例###(symbol-args 'cons) → 2
	  #####(symbol-args 'list) → -1
	  #####(symbol-args 'if)## → 0
	  #####(symbol-args 'fib)##→#(n)
	  #####(symbol-args 'setf)#→#(&rest l)

boundp <symbol>
	##組込関数 (p.103 lcont.p)
	  機能 シンボルが値を持つか？
	##値 ##シンボルが値を持てば t それ以外は#nil

fboundp <symol>#####!
	##組込関数 (p.103 lcont.p)
	  機能 シンボルに関数が束縛されているか？
	##値 ##シンボルに関数が束縛されているならば t
	#######それ以外は#nil

special-form-p <symbol>
	##組込関数 (p.103 lcont.p)
	  機能 スペシャルフォームか？
	##値 ##特殊形式 (fsubr) の場合 t、それ以外は#nil

setq {val form}
	##特殊形式 (p.104 lcont.p)
	  機能 シンボルに対する束縛
	  #####<val>...##束縛されるシンボル（クォートされる）
	#######<form>...#束縛する値
	##値 ##最後に束縛する値
	##例###(setq a (+ 1 2 3) b (cons#a)) →#(6)

psetq {val form}
	##特殊形式 (p.104 lcont.p)
	  機能 setq 関数の並列版
	  #####<val>...##束縛されるシンボル（クォートされる）
	#######<form>...#束縛する値
	#######（同じシンボルの束縛は最初のもののみ有効です）
	##値 ##nil
	##例###(psetq a 1 b 2)(psetq a b b a)
		→ [a==2,b==1]
	  #####(psetq a 1 a 2) → [a==1]

set <symbol>#<value>
	##組込関数 (p.105 lcont.p)
	  機能 シンボルに対する束縛
	  #####<symbol>##束縛されるシンボル
	  #####<value>	###束縛する値
	##値 ##束縛する値
	##例###(set 'a 1) → [a==1]

swap <symbol1>#<symbol2>
	##組込関数 (lcont.p)
	  機能 シンボルに対する束縛値の交換
	#######<symbol>##束縛されるシンボル
	  値 ##<symbol1>#を束縛していた値
	##例###(setq a 1 b 2)(swap a b) → 2 [a==2, b==1]


makunbound <symbol>
	##組込関数 (p.105 lcont.p)
	  機能 値を未定義にする
	##値 ##引数そのもの

fmakunbound <symbol>
	##組込関数 (p.105 lcont.p)
	  機能 関数定義を未定義にする
	##値 ##（ただのシンボルになった）引数そのもの

setf <place>#<newvalue>
	##マクロ (p.107 init.lsp)
	  機能 汎変数の変更
	##値 ##束縛する値
	##例###(setf a '(1 2 3 4)) →# #(1 2 3 4)
	  #####(setf (nth 2 a)#'c) →# c
		a	#####→##(1 2 c 4)
	  #####(setf (car a)#'a)## →# #a
		a	#####→## #(a 2 c 4)
	  #####(setf (cdr#a)#'b)## →# b
		a	#####→## #(a . b)

apply#<function>#<arg> &rest <more-args>
	##組込関数 (p.125 lcont.p)
	  機能 引数（リスト）を使用して関数を適用する
	#######<function># 適用する関数（または関数名）
	#######<args>	#####引数のリスト
	##値 ##引数に対して関数を適用した値
	##備考 λογοσでは function が特殊形式であっても、マクロ
	#######であっても整合性がとれていれば動作する
	#######（apply#の引数を再構成してから、eval に渡しているため）
	##例###(apply##'max 3 5 '(2 7 3)) →# 7.000
	  #####(apply#'cons '((+2 3) 4)) →# #((+ 2 3).4)
	  #####(apply#'if t '(1 2))	→   1
	  #####(apply#'(lambda (x y) (+ x y))'(1 2)) → 3

funcall <fn> &rest <arguments>
	##組込関数 (p.125 lcont.p)
	  機能 引数を使用して関数を呼び出す
	#######<fn> 呼び出す関数（または関数名）
	#######<args>	#関数に渡す引数
	##値 ##関数呼び出しの結果の値
	##備考 λογοσでは fn が特殊形式であっても、マクロであっ
	#######ても整合性がとれていれば動作する
	#######（funcall の引数を単純に eval に渡しているため）
	##例###(funcall '+####1 2) →# #3
	  #####(funcall 'if t 1 2) →# #1

progn {form}
	##特殊形式 (p.126 lcont.p)
	  機能 式の逐次実行
	##値 ##最後の式の値

prog1 <first> {form}
	##特殊形式 (p.127 lcont.p)
	  機能 式の逐次実行
	##値 ##最初の式 <first> の値

prog2 <first> <second> {form}
	##特殊形式 (p.127 lcont.p)
	  機能 式の逐次実行
	##値 ##２番目の式 <second> の値

let ({var}){form}let ({var}|{var init}){form}
	##特殊形式 (p.128 lcont.p init.lsp)
	  機能 局所的な束縛の生成（psetq による束縛）
	#######{var} ##局所変数の並び
	#######{form}	 評価される式の並び
	##備考 ブロックを生成しません
	#######初期化構文はサポートされていません
	#######ただし、init.lsp#を読み込むと、初期化構文が使えるよう
	#######になります。
	#######局所変数の初期値は#nil#になります
	##値 ##最後の式の値
	##例###(let (x)(setq x (time))
		####(prin1 x))
	#######＊ init.lsp 読み込み時可能な表現
	  #####(let ((x 1)(y 2))(prin1 (* x y)))

let* ({var}|{var init}){form}
	##マクロ (p.128 lcont.p init.lsp)
	  機能 局所的な束縛の生成（setq による束縛）
	#######{var} ##局所変数の並び
	#######{form}	 評価される式の並び
	##備考 ブロックを生成しません
	#######初期化構文はサポートされていません
	#######ただし、init.lsp#を読み込むと、初期化構文が使えるよう
	#######になります。
	#######局所変数の初期値は#nil#になります
	##値 ##最後の式の値

if <test>#<then> [<else>]
	  特殊形式 (p.135 lcont.p)
	  機能 条件による式の評価
	#######<test>	 条件式
	#######<then>	 test が非#nil#の場合に評価される式
	#######<else>	 test が#nil#の場合に評価される式
	##値 ##選択されたどちらかの式の値
	##例###(if (> (random 100) 50) t#nil)

when <test>#{form}
	##特殊形式 (p.135 lcont.p)
	  機能 条件が真の場合にのみ評価する
	#######<test>	 条件式
	#######{form}	 test が非#nil#の場合に評価される式の並び
	##値 ##最後の式の値または#nil

unless <test>#{form}
	##特殊形式 (p.135 lcont.p)
	  機能 条件が偽の場合にのみ評価する
	#######<test>	 条件式
	#######{form}	 test が#nil#の場合に評価される式の並び
	##値 ##最後の式の値または#nil

while <condition>{body}
	##マクロ (init.lsp)
	  機能 Ｃライクな while ループ
	#######<condition> 条件判断
	#######{body}	 ループ本体（明示的な progn 関数と同じ）
	##例###(setq x 0)(while (< x 10)(print x)(incf x))
	#######→ 0 から 9 まで表示

for ((<sym> <init>)<condition><step>)#{body}
	##マクロ (init.lsp)
	  機能 Ｃライクな for ループ
	#######<sym>	 値を束縛するシンボル
	#######<init>	 初期値
	#######<condition> 条件判断
	#######{body}	 ループ本体（明示的な progn 関数と同じ）
	##例###(for ((x 0)(< x 10)(incf x))(print x))
	#######→ 0 から 9 まで表示

cond {(test {form})}
	##特殊形式 (p.136 lcont.p)
	  機能 条件評価
	#######<test>	 条件式
	#######{form}	 test が非#nil#の場合に評価される式の並び
	##値 ##述語が非#nil#であった最初の式の値

case <keyform> {(key{form})}	###特殊形式 (p.137 lcont.p)
	  機能 ケース選択
	#######<keyform> 選択式
	#######<key>	###単一の式（評価されない）
	#######{form}	   case が適合または#key が#t の場合に実行す
	#######る式
	##値 ##適合した case の最後の式の値
	##例###(case 2 (1 1)(2 (cons 1 2))(3 3)) →#(1 . 2)
	  #####(case 4 (1 1)(2 2)(t 'no)) → no

typecase <keyform> {(key{form})}
	##マクロ (p.137 init.lsp)
	  機能 型によるケース選択
	#######<keyform> 選択式
	#######<key>	###単一の型名（評価されない）
	#######{form}	   型が適合または#key が#t の場合に実行する
	#######式
	##値 ##適合した型の最後の式の値
	##例###(typecase 4 (symbol 1)(fixnum 2)(t 'no))
			#→ 2

block <name>#{form}
	##特殊形式 (p.139 lcont.p)
	  機能 名前付きブロック
	#######<name>	 ブロックの名称（シンボル、評価されない）
	#######{form}	 ブロック本体
	##値 ##最後の式の値

return-from <name>#[<value>]
	  特殊形式 (p.139 lcont.p)
	  機能 ユーザー関数及び名前付きブロックからのリターン
	#######<name>	 ブロック名（シンボル、評価されない）
	#######<value>	 戻り値（デフォルトは#nil#）
	##値 ##帰ってこない
	##備考 指定されたブロックに復帰する前に、それまでになされて
	#######いた束縛を解放する
	##例###(defun test (x)
		####(cond ####((eq x 0)(print 'Zero))
		 #####((eq x 1)(return-from sample 'One-Break!))
		 #####(t####(print 'Else))))
	  #####(defun sample (y)
		####(progn ###(print 'start)
			#(test y)
			#(print 'end)))
	  #####ここで、(sample 0) → end
		####(sample 1) → one-break!
		####(test 1) ##→ エラー####となります

return#[<value>]
	  特殊形式 (p.139 lcont.p)
	  機能 名前が#nil#のブロック（let,prog など）からリターン
	#######<value>	 戻り値（デフォルトは#nil#）
	##値 ##帰ってこない
	##備考 (return-from nil#<value>)#と同等です

loop#{form}
	##特殊形式 (p.140 lcont.p)
	  機能 基本ループ形式
	#######{form}	 ループの本体
	#######暗に#nil#という名前のブロックを生成します
	##値 ##帰ってこない（非局所出口を設定する必要あり）
	##例###(setq x 0)
	  #####(loop	#(incf x)
		####(prin1 x)(print '\t)
		####(if (eq x 100)
		####(return#x)))
		→ 100 まで表示して 100 を返す

do ({var|(var [init [step]])})(end-test {result}){body}
	##マクロ (p.141 init.lsp)
	  機能 リストを使ったループ
	#######<var>	###各要素を束縛するシンボル（psetq による）
	#######<init>	 ##初期値
	#######<step>	 ##更新式
	#######<end-test> 終了条件式
	#######<result>##値式（デフォルトは#nil#）
	#######{body}	 ##ループ本体（明示的な prog 関数と同じ）
	##例###(do ((x '(1 2 3)#(cdr x))
		####(y '() #####(cons#(car x) y)))
		####((endp x) y)
		####(princ#(car x)) )
	#######→   123#と印字して (3 2 1) を返す

do* ({var|(var [init [step]])})(end-test {result}){body}
	##マクロ (p.141 init.lsp)
	  機能 リストを使ったループ
	#######<var>	###各要素を束縛するシンボル（set による）
	#######<init>	 ##初期値
	#######<step>	 ##更新式
	#######<end-test> 終了条件式
	#######<result>##値式（デフォルトは#nil#）
	#######{body}	 ##ループ本体（明示的な prog* 関数と同じ）
	##例###(do* ((x '(1 2 3)#(cdr x))
		####(y '() #####(cons#(car x) y)))
		####((endp x) y)
		####(princ#(car x)) )
	#######→   123#と印字して (3 2 1) を返す

dolist (<sym> <list> <result>)#{body}
	##マクロ (p.145 init.lsp)
	  機能 リストを使ったループ
	#######<sym>	 リストの各要素を束縛するシンボル
	#######<list>	 リスト式
	#######<result>#値式（デフォルトは#nil#）
	#######{body}	 ループ本体（明示的な prog 関数と同じ）
	##例###(dolist (x '(1 2 3)#4)#(print x))
	#######→   123#と印字して 4 を返す

dotimes#(<sym> <num> <result>)#{body}
	##マクロ (p.146 init.lsp)
	  機能 0 から n-1 迄のループ
	#######<sym>	 0 から n-1 迄の値を束縛するシンボル
	#######<num>	 ループする回数
	#######<result>#値式（デフォルトは#nil#）
	#######<expr>	#ループ本体（明示的な prog 関数と同じ）
	##例###掛け算の九九
	  #####(dotimes#(x 10 ' 九九 )
		####(terpri)
		####(dotimes#(y 10)
			#(print (* x y))(print '\ )))
	  #####0#0#0#0#0#0#0#0#0#0
	  #####0#1 2 3 4 5 6 7 8 9
	  #####0#2 4 6 8 10 12 14 16 18
	  #####0#3 6 9 12 15 18 21 24 27
	  #####0#4 8 12 16 20#24 28 32 36
	  #####0#5 10 15 20#25 30#35 40 45
	  #####0#6 12 18 24 30#36 42 48 54
	  #####0#7 14 21 28 35 42 49 56 63
	  #####0#8 16 24 32 40 48 56 64 72
	  #####0#9 18 27#36 45 54 63 72 81 九九

mapcar <function> <list> &rest <more-lists>
	  組込関数 (p.147 lcont.p)
	  機能 後続の car 群を引数として関数を適用する
	#######<function> 関数または関数名称
	#######<list>	 ##関数の引数をリストにしたもの
	##値 ##返ってきた値のリスト
	##例###(mapcar #'cons#'(a b c)'(1 2 3))
	#######→   ((a . 1)(b . 2)(c . 3))

maplist <function> <list> &rest <more-lists>
	  組込関数 (p.147 lcont.p)
	  機能 後続の cdr 群を引数として関数を適用する
	#######<function> 関数または関数名称
	#######<list>	 ##関数の引数をリストにしたもの
	##値 ##返ってきた値のリスト
	##例###(maplist #'cons#'(a b c)'(1 2 3))
	#######→   (((a b c)#1 2 3)#((b c)#2 3)#((c)#3))

mapc <function> <list> &rest <more-lists>
	  組込関数 (p.147 lcont.p)
	  機能 後続の car 群を引数として関数を適用する
	#######<function> 関数または関数名称
	#######<list>	 ##関数の引数をリストにしたもの
	##値 ##引数の最初のリスト
	##例###(mapc #'cons#'(a b c)'(1 2 3))
	#######→   (a b c)

mapl <function> <list> &rest <more-lists>
	  組込関数 (p.147 lcont.p)
	  機能 後続の cdr 群を引数として関数を適用する
	#######<function> 関数または関数名称
	#######<list>	 関数の引数をリストにしたもの
	##値 ##返ってきた値のリスト
	##例###(mapl #'cons#'(a b c)'(1 2 3))
	#######→   (a b c)

mapcan <function> <list> &rest <more-lists>
	  組込関数 (p.147 lcont.p)
	  機能 後続の car 群を引数として関数を適用する
	#######<function> 関数または関数名称
	#######<list>	 ##関数の引数をリストにしたもの
	##値 ##返ってきた値のリスト（破壊型）
	##例###(mapcar #'cons#'(a b c)'(1 2 3))
	#######→   ((a . 1)(b . 2)(c . 3))
	  #####(mapcan #'(lambda#(x)(and (numberp x)(list x)))
		####'(a 1 b 2 c 3))
	#######→   (1 2 3)

mapcan <function> <list> &rest <more-lists>
	  組込関数 (p.147 lcont.p)
	  機能 後続の cdr 群を引数として関数を適用する
	#######<function> 関数または関数名称
	#######<list>	 ##関数の引数をリストにしたもの
	##値 ##返ってきた値のリスト（破壊型）

tagbody {<tag> | statement}
	##特殊形式 (p.149 lcont.p)
	  機能 ラベル付きブロック
	##値 ##nil

prog ({var}){<tag>| statement}
	##特殊形式 (p.151 lcont.p init.lsp)
	  機能 プログラム機能（psetq による束縛）
	##備考 init.lsp を読み込むと、初期化構文が仕様できます。
	##値 ##nil またはリターン関数の引数

prog* ({var}|{var init}){<tag>| statement}
	##マクロ (p.151 init.lsp)
	  機能 プログラム機能（setq による束縛）
	##値 ##nil またはリターン関数の引数

go <tag>
	##特殊形式 (p.153 lcont.p)
	  機能 タグ本体内または prog 内 go to
	##値 ##帰ってこない

catch <tag> {form}
	##特殊形式 (p.162 lcont.p)
	  機能 式の評価及びキャッチ
	#######<tag>	 キャッチタグ（評価される）
	#######{form}	 評価する式
	##備考 現在、tag が評価される点以外は動作は#block#と同じで
	##値 ##最後に評価した値または throw した最後の式の値

unwind-protect <protected-form> {cleaup-form}
	##特殊形式 (p.162 lcont.p)
	  機能 式評価の防御
	#######<protected-form> 防御する式
	#######{cleanup-form} クリーンアップ式
	##備考 防御する式が非局所出口によって評価中断された場合でも、
	#######クリーンアップ式の評価を行います。
	##値 ##式の値
	##例###(block#a#(unwind-protect
			#(return-from#a#'ok)
			#(print "cleaning-form")))
	  #####→ "cleaning-form" を表示し、ok#を返します

throw <tag> [<result>]
	  組込関数 (p.166 lcont.p)
	  #####<tag>	 キャッチタグ（評価される）
	#######<result>#キャッチに返す戻り値（デフォルトは#nil#）
	##備考 現在、tag が評価される点以外は動作は#return-from#と同
	  #####じ
	##値 ##帰ってこない


#####［第８章##マクロ］
#####------------------


defmacro <name> <lambda-list> {form}
	##特殊形式 (p.169 leval.p)
	  機能 マクロ関数を定義する
	##値 ##関数名

dm	 <name> <lambda-list> {form}
	##特殊形式 (p.169 leval.p)
	  機能 マクロ関数を定義する
	##値 ##関数名


#####［第９章##宣言］
#####----------------


declare <decl-spec>
	##特殊形式 (p.186 ldeclare.p)
	  機能 宣言を行う
	##値 ##引き数リスト
	##備考 インタプリタでは何もしません

the <value-type> <form>
	##特殊形式 (p.205 ldeclare.p)
	  機能 式の評価結果の型を規定する
	#######<valu-type> 規定する型
		####symbol	###シンボル
		####cons	###コンスセル
		####array	 ##配列（ベクタ）
		####（構造体型名） 構造体
		####subr	 ##組込関数
		####fsubr	 ##特殊形式
		####expr	 ##ＥＸＰＲ型関数
		####fexpr	 ##ＦＥＸＰＲ型関数
		####macro	 ##ＭＡＣＲＯ型関数
		####string	 ##文字列型
		####fixnum	 ##整数型
		####floanum	 ##浮動小数点型
		####character#文字型
	##値 ##評価結果
	##備考 副型等はサポートしていない
	##例###(the floanum 5.3)#→ 5.3
	  #####(the cons#5.3)#→ エラー


#####［第１０章##シンボル］
#####----------------------


get <symbol> <indicator> &optional <default>
	  組込関数 (p.208 lsymbol.p)
	  機能 属性値の取得
	#######<symol>	#####シンボル
	#######<indicator> 属性（シンボル）
	#######<default> ##属性がなかった場合のデフォルト値
	##値 ##属性値またはデフォルト値

getprop <symbol> <indicator> &optional <default>
	  組込関数 (p.208 lsymbol.p)
	  機能 属性値の取得
	#######<symol>	#####シンボル
	#######<indicator> 属性（シンボル）
	#######<default> ##属性がなかった場合のデフォルト値
	##値 ##属性値またはデフォルト値

remprop <symol> <indicator>
	  組込関数 (p.209 lsymbol.p)
	  機能 属性の削除
	#######<sym>	###シンボル
	#######<indicator> 属性（シンボル）
	##値 ##属性がみつからなければ#nil、見つかれ		#ば
	#######非#nil

symbol-plist <symbol>
	  組込関数 (p.210 lsymbol.p)
	  機能 属性を取り出す
	##値 ##属性または nil

put <symol> <indicator> <value>
	  組込関数 (lsymbol.p)
	  機能 属性リストへの書き込み
	#######<symol>	#####シンボル
	#######<indicator> 属性（シンボル）
	#######<value>	#####属性値
	##値 ##属性リスト

putprop <symol> <indicator> <value>
	  組込関数 (lsymbol.p)
	  機能 属性リストへの書き込み
	#######<symol>	#####シンボル
	#######<indicator> 属性（シンボル）
	#######<value>	#####属性値
	##値 ##属性リスト

set-plist <symbol> <plist>
	  組込関数 (p.210 lsymbol.p)
	  機能 属性を設定する
	##値 ##与えられた属性

getf <place> <indicator> &optional <default>
	  組込関数 (p.210 lsymbol.p)
	  機能 属性値の取得
	#######<place>	#####属性リスト
	#######<indicator> 属性（シンボル）
	#######<default> ##属性がなかった場合のデフォルト値
	##値 ##属性値またはデフォルト値

symbol-name#<sym>
	  組込関数 (p.211 lsymbol.p)
	  機能 シンボルアトムの印字名を文字列として返す
	##値 ##シンボルアトムの印字名に等しい文字列

make-symbol#<string>
	  組込関数 (p.212 lsymbol.p)
	  機能 文字列をシンボルアトムにして返す
	##値 ##文字列に等しい印字名を持つシンボルアトム

gensym	  &optional <x>
	  組込関数 (p.213 lsymbol.p)
	  機能 新しいシンボルを作る
	#######<x> #前置詞となる文字列
	##値 ##前置詞となる文字列と *gensym-counter*
	  #####の数値を合わせ、シンボルアトムにしたもの
	##備考 コモンリスプとは違い、インターンされます。
	#######前置詞となる文字列は保存されませんので、同じ前置詞を
	#######付けたい場合には毎回
	#######指定する必要があります。
	#######*gensym-counter* が負でも動作します。

pack#<list>
	  組込関数 (lsymbol.p)
	  機能 引き数リストの中に含まれるシンボルア
	#######トム名をつなげて新たなシンボルアトム
	  #####を生成する
	##値 ##生成されたシンボルアトム
	  備考 nil#や eof、unk#を生成要素として使用する
	#######場合は、エラーになることがあります
	##例###(pack#'(abc '\123))##→	abc123

pack* <symbol> &rest <symbol>
	  組込関数 (lsymbol.p)
	  機能 シンボルアトム名をつなげて新たなシン
	#######ボルアトムを生成する
	##値 ##生成されたシンボルアトム
	  備考 nil#や eof、unk#を生成要素として使用する
	#######場合は、エラーになることがあります
	##例###(pack* 'abc '\123)##→##abc123

unpack#<symbol>
	  組込関数 (lsymbol.p)
	  機能 シンボルアトム名を分解します
	##値 ##生成されたシンボルアトムのリスト
	##例###(unpack#'abc123)#→#(a b c 1 2 3)

oblist
	  組込関数 (lsymbol.p)
	  機能 登録された全てのシンボルアトムをリストにします
	##値 ##全てのシンボルアトムのリスト


#####［第１１章##パッケージ］
#####------------------------

do-symbols (<sym> <result>) {body}
	  マクロ (p.240 init.lsp)
	  機能 全てのシンボルアトムに対するループ
	#######<sym>	#各シンボルアトムを登録の逆順に束縛するシン
			#ボルアトム (oblist#の順に束縛 )
	  #####<result>#値式（デフォルトは nil ）
	#######{body}	#ループ本体（明示的な prog 関数と同じ）
	##例###(do-symbols (x 999)
		####(if (eq (character#x) #\a)
			######(print#x)))
	  #####→## a から始まるシンボルアトムを全て表示し、999#を返
	  #####す

do-all-symbols (<sym> <result>) {body}
	  マクロ (p.241 init.lsp)
	  機能 全てのシンボルアトムに対するループ
	#######<sym>	#各シンボルアトムを登録の逆順に束縛するシン
	#######ボルアトム (oblist#の順に束縛 )
	  #####<result>#値式（デフォルトは nil ）
	#######{body}	#a#ループ本体（明示的な prog 関数と同じ）
	##例###(do-all-symbols (x 999)
		####(if (eq (character#x) #\a)
			######(print#x)))
	  #####→## a から始まるシンボルアトムを全て表示し、999#を返
	  #####す


#####［第１２章##数］
#####----------------


zerop <number>
	  組込関数 (p.255 lmath.p)
	  機能 ゼロか？
	##値 ##ゼロならば t#それ以外は nil
	##備考 浮動小数点数の場合、0.0 も -0.0 もゼロとみなします

natnump <number>
	  組込関数 (p.255 lmath.p)
	  機能 自然数か？
	##値 ##自然数ならば t#それ以外は nil
	##備考 浮動小数点数の場合エラーになります

minusp <number>
	  組込関数 (p.255 lmath.p)
	  機能 負か？
	##値 ##負ならば t#それ以外は nil

plusp <number>
	  組込関数 (p.255 lmath.p)
	  機能 正か？
	##値 ##正ならば t#それ以外は nil

oddp <number>
	  組込関数 (p.255 lmath.p)
	  機能 奇数か？
	##値 ##奇数ならば t#それ以外は nil

evenp <number>
	  組込関数 (p.255 lmath.p)
	  機能 偶数か？
	##値 ##偶数ならば t#それ以外は nil

=##<number> &rest <more-numbers>
	  組込関数 (p.256 lmath.p)
	  機能 イコールか？
	##値 ##右から左にを比較した結果により、t#または nil

==#<number> &rest <more-numbers>*
	  組込関数 (p.256 lmath.p)
	  機能 イコールか？
	##値 ##右から左にを比較した結果により、t#または nil

!=#<number> &rest <more-numbers>
	  組込関数 (p.256 lmath.p)
	  機能 イコールではないか？
	##値 ##右から左にを比較した結果により、t#または nil

/=#<number> &rest <more-numbers>
	  組込関数 (p.256 lmath.p)
	  機能 イコールではないか？
	##値 ##右から左にを比較した結果により、t#または nil

<##<number> &rest <more-numbers>
	  組込関数 (p.256 lmath.p)
	  機能 より小さいか？
	##値 ##右から左にを比較した結果により、t#または nil

> #<number> &rest <more-numbers>
	  組込関数 (p.256 lmath.p)
	  機能 より大きいか？
	##値 ##右から左にを比較した結果により、t#または nil

<=#<number> &rest <more-numbers>
	  組込関数 (p.256 lmath.p)
	  機能 以下か？
	##値 ##右から左にを比較した結果により、t#または nil

=<#<number> &rest <more-numbers>
	  組込関数 (p.256 lmath.p)
	  機能 以下か？
	##値 ##右から左にを比較した結果により、t#または nil

>=#<number> &rest <more-numbers>
	  組込関数 (p.256 lmath.p)
	  機能 以上か？
	##値 ##右から左にを比較した結果により、t#または nil

=> <number> &rest <more-numbers>
	  組込関数 (p.256 lmath.p)
	  機能 以上か？
	##値 ##右から左にを比較した結果により、t#または nil

greaterp <n1> <n2>
	  組込関数 (lmath.p)
	  機能 n1 が n2 より大きいか（左を右と比較）
	#######<n1> 比較する整数
	#######<n2> 比較される整数
	##備考 整数専用であることと多引数比較との順序の違いに注意
	##値 ##<n1> と#<n2> #を比較した値

lessp <n1> <n2>
	  組込関数 (lmath.p)
	  機能 n1 が n2 より小さいか（左を右と比較）
	#######<n1> 比較する整数
	#######<n2> 比較される整数
	##備考 整数専用であることと多引数比較との順序の違いに注意
	##値 ##<n1> と#<n2> #を比較した値

notgreaterp <n1> <n2>
	  組込関数 (lmath.p)
	  機能 n1 が n2 より大きくないか（左を右と比較）
	#######<n1> 比較する整数
	#######<n2> 比較される整数
	##備考 整数専用であることと多引数比較との順序の違いに注意
	##値 ##<n1> と#<n2> #を比較した値

notgreaterp <n1> <n2>
	  組込関数 (lmath.p)
	  機能 n1 が n2 より小さくないか（左を右と比較）
	#######<n1> 比較する整数
	#######<n2> 比較される整数
	##備考 整数専用であることと多引数比較との順序の違いに注意
	##値 ##<n1> と#<n2> #を比較した値

max <number> &rest <more-numbers>
	  組込関数 (p.257 lmath.p)
	  機能 最大値を求める
	##値 ##引数リストの中で一番大きな数値（浮動小数点型になる）

min <number> &rest <more-numbers>
	  組込関数 (p.257 lmath.p)
	  機能 最小値を求める
	##値 ##引数リストの中で一番小さな数値（浮動小数点型になる）

greater <n1> <n2>
	  組込関数 (lmath.p)
	  機能 n1 と n2 のうち大きい方をとる（二引数整数の max）
	##値 ##引数リストの中で一番大きな数値

less <n1> <n2>
	  組込関数 (lmath.p)
	  機能 n1 と n2 のうち小さい方をとる（二引数整数の min）
	##値 ##引数リストの中で一番小さな数値

+ &rest <numbers>
	  組込関数 (p.258 lmath.p)
	  機能 数値（リスト）の加算
	##値 ##加算の結果（自動型合わせを行う）
	#######あるいは引数がなければ 0
	##備考 引数が２つでともに整数ならば add、浮動小数点数ならば
	#######f+ の方が高速

plus &rest <numbers>
	  組込関数 (p.258 lmath.p)
	  機能 数値（リスト）の加算
	##値 ##加算の結果（自動型合わせを行う）
	#######あるいは引数がなければ 0
	##備考 引数が２つでともに整数ならば add、浮動小数点数ならば
	#######f+ の方が高速

add <num1> <num2>
	  組込関数 (lmath.p)
	  機能 ２つの整数の加算
	##値 ##加算の結果

f+ <num1> <num2>
	  組込関数 (lmath.p)
	  機能 ２つの浮動小数点数の加算
	##値 ##加算の結果

- <number> &rest <more-numbers>
	  組込関数 (p.258 lmath.p)
	  機能 数値（リスト）の減算又は一数値の符号反転
	##値 ##減算の結果（自動型合わせを行う）
	#######あるいは符号反転した数値
	##備考 引数が２つでともに整数ならば sub、浮動小数点数ならば
	#######f- の方が高速

difference <number> &rest <more-numbers>
	  組込関数 (p.258 lmath.p)
	##値 ##減算の結果（自動型合わせを行う）
	#######あるいは符号反転した数値
	##備考 引数が２つでともに整数ならば sub、浮動小数点数ならば
	#######f- の方が高速

sub <num1> <num2>
	  組込関数 (lmath.p)
	  機能 ２つの整数の減算
	##値 ##減算の結果

f- <num1> <num2>
	  組込関数 (lmath.p)
	  機能 ２つの浮動小数点数の減算
	##値 ##減算の結果

* &rest <numbers>
	  組込関数 (p.258 lmath.p)
	  機能 数値（リスト）の積算
	##値 ##積算の結果（自動型合わせを行う）
	#######または引数がないときは１
	##備考 引数が２つでともに整数ならば mul、浮動小数点数ならば
	#######f* の方が高速

times &rest <numbers>
	  組込関数 (p.258 lmath.p)
	  機能 数値（リスト）の積算
	##値 ##積算の結果（自動型合わせを行う）
	#######または引数がないときは１
	##備考 引数が２つでともに整数ならば mul、浮動小数点数ならば
	#######f* の方が高速

mul <num1> <num2>
	  組込関数 (lmath.p)
	  機能 ２つの整数の積
	##値 ##積算の結果

f* <num1> <num2>
	  組込関数 (lmath.p)
	  機能 ２つの浮動小数点数の積
	##値 ##積算の結果

/ <number> &rest <more-numbers>
	  組込関数 (p.258 lmath.p)
	  機能 数値（リスト）の除算
	##値 ##除算の値（自動型合わせを行う）
	#######引数がないときは１
	#######引数が一つしかないときは逆数
	##備考 引数が２つでともに整数ならば div、浮動小数点数ならば
	#######f/ の方が高速

quotient <number> &rest <more-numbers>
	  組込関数 (p.258 lmath.p)
	  機能 数値（リスト）の除算
	##値 ##除算の値（自動型合わせを行う）
	#######引数がないときは１
	#######引数が一つしかないときは逆数
	##備考 引数が２つでともに整数ならば div、浮動小数点数ならば
	#######f/ の方が高速

div <num1> <num2>
	  組込関数 (lmath.p)
	  機能 ２つの数値の除算
	##値 ##除算の結果

f/ <num1> <num2>
	  組込関数 (lmath.p)
	  機能 ２つの浮動小数点数の除算
	##値 ##除算の結果

1+##<number>
	  組込関数 (p.259 lmath.p)
	  機能 整数に１を加算する
	##値 ##整数に１を加えたもの

++ <number>
	  組込関数 (p.259 lmath.p)
	  機能 整数に１を加算する
	##値 ##整数に１を加えたもの

add1 <number>
	  組込関数 (p.259 lmath.p)
	  機能 整数に１を加算する
	##値 ##整数に１を加えたもの

inc <number>
	  組込関数 (p.259 lmath.p)
	  機能 整数に１を加算する
	##値 ##整数に１を加えたもの

1-##<number>
	  組込関数 (p.259 lmath.p)
	  機能 整数より１を減算する
	##値 ##整数より１を引いたもの

-- <number>
	  組込関数 (p.259 lmath.p)
	  機能 整数より１を減算する
	##値 ##整数より１を引いたもの

sub1 <number>
	  組込関数 (p.259 lmath.p)
	  機能 整数より１を減算する
	##値 ##整数より１を引いたもの

dec <number>
	  組込関数 (p.259 lmath.p)
	  機能 整数より１を減算する
	##値 ##整数より１を引いたもの

incf <place> [<delta>]
	##特殊形式 (p.260 lmath.p)
	  機能 変数の値を <delta> の評価値分増やす
	#######<place>	 数値変数（クオートされる）
	#######<delta>	#加算する数値（省略時１）
	##値 ##数値に <delta> を評価したものを加えたもの

incq <place> [<delta>]
	##特殊形式 (p.260 lmath.p)
	  機能 変数の値を <delta> の評価値分増やす
	#######<place>	 数値変数（クオートされる）
	#######<delta>	#加算する数値（省略時１）
	##値 ##数値に <delta> を評価したものを加えたもの

decf <place> [<delta>]
	##特殊形式 (p.260 lmath.p)
	  機能 変数の値を <delta> の評価値分減らす
	#######<place>	 数値変数（クオートされる）
	#######<delta>	#減算する数値（省略時１）
	##値 ##数値に <delta> を評価したものを減らしたもの

decq <place> [<delta>]
	##特殊形式 (p.260 lmath.p)
	  機能 変数の値を <delta> の評価値分減らす
	#######<place>	 数値変数（クオートされる）
	#######<delta>	#減算する数値（省略時１）
	##値 ##数値に <delta> を評価したものを減らしたもの

gcd &rest <integers>
	  組込関数 (p.260 lmath.p)
	  機能 最大公約数の算出
	##値 ##最大公約数
	##例###(gcd)	######→ 0
	#######(gcd 91 -49)###→ 7

lcm &rest <integers>
	  組込関数 (p.260 lmath.p)
	  機能 最小公約の算出
	##値 ##最小公約数
	##例###(lcm)	######→ 1
	#######(lcm 1 2 3 4 5 -6)#→ 60

exp <number>
	  組込関数 (p.262 lmath.p)
	  機能 自然対数の底を底とするべき乗の計算をする
	##値 ##e の number 乗

expt <base-number> <power-number>
	  組込関数 (p.262 lmath.p)
	  機能 べき乗の計算をする
	#######<base-number>  被乗数
	#######<power-number> 乗数
	##値 ##<base-number> の <power-number> 乗
	#######乗数が負の場合エラー

log <number> &optional <base>
	  組込関数 (p.263 lmath.p)
	  機能 第２引数を底とする対数を求める
	##値 ##第２引数を底とする対数の値
	#######第２引数が省略されたときには、自然対数を底とした対数
	#######を返す

sqrt <expr>
	  組込関数 (p.264 lmath.p)
	  機能 数値の平方根を求める
	##値 ##数値の平方根

isqrt <expr>
	  組込関数 (p.264 lmath.p)
	  機能 整数の平方根を求める
	##値 ##整数の平方根

cubrt <expr>
	  組込関数 (p.264 lmath.p)
	  機能 数値の立方根を求める
	##値 ##数値の立方根

icubrt <expr>
	  組込関数 (lmath.p)
	  機能 整数の立方根を求める
	##値 ##整数の立方根

abs <number>
	  組込関数 (p.264 lmath.p)
	  機能 数値の絶対値
	##値 ##数値の絶対値

signum <number>
	  組込関数 (p.264 lmath.p)
	  機能 数値の符号
	##値 ##正なら１、零なら０、負なら−１

neg <number>
	  組込関数 (p.266 lmath.p)
	  機能 数値の符号の反転
	##値 ##数値の符号を入れ換えたもの

sin <radians>
	  組込関数 (lmath.p)
	  機能 引数の正弦を求める
	##値 ##引数の正弦
	##備考 引数の単位はラジアン

cos <radians>
	  組込関数 (p.266 lmath.p)
	  機能 引数の余弦を求める
	##値 ##引数の余弦
	##備考 引数の単位はラジアン

tan <radians>
	  組込関数 (p.266 lmath.p)
	  機能 引数の正接を求める
	##値 ##引数の正接
	##備考 引数の単位はラジアン

asin <number>
	  組込関数 (p.266 lmath.p)
	  機能 引数の逆正弦を求める
	##値 ##引数の逆正弦
	##備考 値の単位はラジアン

acos <number>
	  組込関数 (p.266 lmath.p)
	  機能 引数の逆余弦を求める
	##値 ##引数の逆余弦
	##備考 値の単位はラジアン

atan <number>
	  組込関数 (p.266 lmath.p)
	  機能 引数の逆正接を求める
	##値 ##引数の逆正接
	##備考 値の単位はラジアン

sinh <number>
	  組込関数 (p.268 lmath.p)
	  機能 引数の双曲正弦を求める
	##値 ##引数の双曲正弦

cosh <number>
	  組込関数 (p.268 lmath.p)
	  機能 引数の双曲余弦を求める
	##値 ##引数の双曲余弦

tanh <number>
	  組込関数 (p.268 lmath.p)
	  機能 引数の双曲正接を求める
	##値 ##引数の双曲正接

asinh <number>
	  組込関数 (p.269 lmath.p)
	  機能 引数の逆双曲正弦を求める
	##値 ##引数の逆双曲正弦

acosh <number>
	  組込関数 (p.269 lmath.p)
	  機能 引数の逆双曲余弦を求める
	##値 ##引数の逆双曲余弦

atanh <number>
	  組込関数 (p.269 lmath.p)
	  機能 引数の逆双曲正接を求める
	##値 ##引数の逆双曲正接

radian#<degree>
	  組込関数 (lmath.p)
	  機能 度で表現された引数をラジアンに変換する
	##値 ##ラジアンを単位とした値

float <integer>
	  組込関数 (p.307 lmath.p)
	  機能 整数型を浮動小数点型に変換する
	##値 ##浮動小数点型となった数値

integer <integer>
	  組込関数 (p.307 lmath.p)
	  機能 浮動小数点型を整数型に変換する
	##値 ##整数型となった数値

floor <number>
	  組込関数 (p.309 lmath.p)
	  機能 引数を負の無限大に向けて整数に変換する
	##値 ##引数より大きくない最も大きな整数

ceiling <number>
	  組込関数 (p.309 lmath.p)
	  機能 引数を正の無限大に向けて整数に変換する
	##値 ##引数より小さくない最も小さな整数

truncate <number>
	  組込関数 (p.309 lmath.p)
	  機能 引数をゼロに向けて整数に変換する
	##値 ##引数と符号が同じで、その絶対値が引数のそれより大きく
	#######ない最も大きな整数

round <number>
	  組込関数 (p.309 lmath.p)
	  機能 引数を最も近い整数に変換する
	##値 ##引数に最も近い整数
	##備考 小数点以下が 0.5 であるときは、引数よりもその絶対値の
	#######小さい整数に変換される

rem <integer1> <integer2>
	  組込関数 (p.310 lmath.p)
	  機能 第１引数を第２引数で割った余りを求める
	##値 ##第１引数を第２引数で割った余り

logior &rest <integers>
	  組込関数 (p.314 lmath.p)
	  機能 数値（リスト）の論理和
	##値 ##演算値

logxor &rest <integers>
	  組込関数 (p.314 lmath.p)
	  機能 数値（リスト）の排他的論理和
	##値 ##演算値

logand &rest <integers>
	  組込関数 (p.314 lmath.p)
	  機能 数値（リスト）の論理積
	##値 ##演算値

logeqv &rest <integers>
	  組込関数 (p.314 lmath.p)
	  機能 数値（リスト）の排他的否定和
	##値 ##演算値

lognand <int1> <int2>
	  組込関数 (p.314 lmath.p)
	  機能 数値の否定論理積
	##値 ##演算値

lognor <int1> <int2>
	  組込関数 (p.314 lmath.p)
	  機能 数値の否定論理和
	##値 ##演算値

logandc1 <int1> <int2>
	  組込関数 (p.314 lmath.p)
	  機能 引数１の補数と引数２の論理積
	##値 ##演算値

logandc2 <int1> <int2>
	  組込関数 (p.314 lmath.p)
	  機能 引数１と引数２の補数の論理積
	##値 ##演算値

logorc1 <int1> <int2>
	  組込関数 (p.314 lmath.p)
	  機能 引数１の補数と引数２の論理和
	##値 ##演算値

logorc2 <int1><int2>
	  組込関数 (p.314 lmath.p)
	  機能 引数１と引数２の補数の論理和
	##値 ##演算値

lognot <integer>
	  組込関数 (p.316 lmath.p)
	  機能 ビットごとの論理的な否定
	##値 ##演算値

logtest <int1> <int2>
	  組込関数 (p.316 lmath.p)
	  機能 引数１と引数２のビットで重なっているところがあるか
	##値 ##ひとつでもあれば t#なければ nil

logbitp <index> <integer>
	  組込関数 (p.316 lmath.p)
	  機能 index で示されたビットが１であるか
	##値 ##2 の index 乗に相当するビットが 1 であるときに t
	#######そうでなければ nil

ash  <integer> <count>
	  組込関数  (p.317 lmath.p)
	  機能 数値のシフト
	##値 ##<integer> を <count> 左にシフト
	#######(<count> が負なら右にシフト）

logcount <integer>
	  組込関数 (p.317 lmath.p)
	  機能 引数に１であるビットがいくつあるか
	##値 ##１であるビットの数

random <n>
	  組込関数 (p.321 lmath.p)
	  機能 １から n-1 の乱数生成
	#######<n>##上限値（整数）
	##値 ##乱数


#####［第１３章##文字］
#####------------------


standard-char-p <char>
	  組込関数 (p.330 lchar.p)
	  機能 標準文字（標準アスキー、改行、空白）か
	##値 ##標準文字ならば t#それ以外は nil

graphic-char-p <char>
	  組込関数 (p.330 lchar.p)
	  機能 印字可能文字（標準アスキー）か
	##値 ##印刷可能文字ならば t#それ以外は nil
	##備考 全角文字は nil

alpha-char-p <char>
	  組込関数 (p.331 lchar.p)
	  機能 アルファベットか
	##値 ##アルファベットならば t#それ以外は nil

upper-case-p <char>
	  組込関数 (p.331 lchar.p)
	  機能 大文字か
	##値 ##アルファベット大文字ならば t#それ以外は nil

lower-case-p <char>
	  組込関数 (p.331 lchar.p)
	  機能 小文字か
	##値 ##アルファベット小文字ならば t#それ以外は nil

both-case-p <char>
	  組込関数 (p.331 lchar.p)
	  機能 その文字に対応する大文字または小文字があるか
	##値 ##アルファベットならば t#それ以外は nil
	##備考 alph-char-p と同じ

digit-char-p <char> &optional (radix 10)
	  組込関数 (p.331 lchar.p)
	  機能 第二引数（デフォルトは１０）を基数としたとき数字か？
	##値 ##第二引数を基数としたときの数値または nil

alphanumericp <char>
	  組込関数 (p.332 lchar.p)
	  機能 数字もしくはアルファベットか
	##値 ##数字かアルファベットならば t#それ以外は nil

kanap <char>
	  組込関数 (lchar.p)
	  機能 仮名文字（#\ア から #\ン および #\゜ と #\゛）か
	##値 ##仮名文字ならば t#それ以外は nil

kigoup <char>
	  組込関数 (lchar.p)
	  機能 仮名句読点（#\。 #\「 #\」 #\、 #\・）か
	##値 ##仮名句読点ならば t#それ以外は nil

char=  <character> &rest <characters>
	  組込関数 (p.332 lchar.p)
	  機能 文字が等しいか
	##備考 大文字／小文字の違いは意味を持つ
	#######全角文字も比較できる
	##値 ##文字をそのアスキーコードで比較し、述語が真ならば t#そ
	#######れ以外は nil

char== <character> &rest <characters>
	  組込関数 (p.332 lchar.p)
	  機能 文字が等しいか
	##備考 大文字／小文字の違いは意味を持つ
	#######全角文字も比較できる
	##値 ##文字をそのアスキーコードで比較し、述語が真ならば t#そ
	#######れ以外は nil

char!= <character> &rest <characters>
	  組込関数 (p.332 lchar.p)
	  機能 文字が全て等しくないか
	##備考 大文字／小文字の違いは意味を持つ
	#######全角文字も比較できる
	##値 ##文字をそのアスキーコードで比較し、述語が真ならば t#そ
	#######れ以外は nil

char/= <character> &rest <characters>
	  組込関数 (p.332 lchar.p)
	  機能 文字が全て等しくないか
	##備考 大文字／小文字の違いは意味を持つ
	#######全角文字も比較できる
	##値 ##文字をそのアスキーコードで比較し、述語が真ならば t#そ
	#######れ以外は nil

char<  <character> &rest <characters>
	  組込関数 (p.332 lchar.p)
	  機能 より小さいか
	##備考 大文字／小文字の違いは意味を持つ
	#######全角文字も比較できる
	##値 ##文字をそのアスキーコードで比較し、述語が真ならば t#そ
	#######れ以外は nil

char>##<character> &rest <characters>
	  組込関数 (p.332 lchar.p)
	  機能 より大きいか
	##備考 大文字／小文字の違いは意味を持つ
	#######全角文字も比較できる
	##値 ##文字をそのアスキーコードで比較し、述語が真ならば t#そ
	#######れ以外は nil

char<= <character> &rest <characters>
	  組込関数 (p.332 lchar.p)
	  機能 以下か？
	##備考 大文字／小文字の違いは意味を持つ
	#######全角文字も比較できる
	##値 ##文字をそのアスキーコードで比較し、述語が真ならば t#そ
	#######れ以外は nil

char=< <character> &rest <characters>
	  組込関数 (p.332 lchar.p)
	  機能 以下か？
	##備考 大文字／小文字の違いは意味を持つ
	#######全角文字も比較できる
	##値 ##文字をそのアスキーコードで比較し、述語が真ならば t#そ
	#######れ以外は nil

char>= <character> &rest <characters>
	  組込関数 (p.332 lchar.p)
	  機能 以上か？
	##備考 大文字／小文字の違いは意味を持つ
	#######全角文字も比較できる
	##値 ##文字をそのアスキーコードで比較し、述語が真ならば t#そ
	#######れ以外は nil

char=> <character> &rest <characters>
	  組込関数 (p.332 lchar.p)
	  機能 以上か？
	##備考 大文字／小文字の違いは意味を持つ
	#######全角文字も比較できる
	##値 ##文字をそのアスキーコードで比較し、述語が真ならば t#そ
	#######れ以外は nil

char-equal <character> &rest <characters>
	  組込関数 (p.334 lchar.p)
	  機能 等しいか
	##備考 大文字／小文字の違いは意味を持たない
	#######全角文字も比較できる
	##値 ##文字がアルファベットであるときは、大文字として扱かっ
	#######た上で、文字をそのアスキーコードで比較し、述語が真な
	#######らば t#それ以外は nil

char-not-equal <character> &rest <characters>
	  組込関数 (p.334 lchar.p)
	  機能 等しくないか
	##備考 大文字／小文字の違いは意味を持たない
	#######全角文字も比較できる
	##値 ##文字がアルファベットであるときは、大文字として扱かっ
	#######た上で、文字をそのアスキーコードで比較し、述語が真な
	#######らば t#それ以外は nil

char-lessp <character> &rest <characters>
	  組込関数 (p.334 lchar.p)
	  機能 小さいか
	##備考 大文字／小文字の違いは意味を持たない
	#######全角文字も比較できる
	##値 ##文字がアルファベットであるときは、大文字として扱かっ
	#######た上で、文字をそのアスキーコードで比較し、述語が真な
	#######らば t#それ以外は nil

char-not-lessp <character> &rest <characters>
	  組込関数 (p.334 lchar.p)
	  機能 小さくないか
	##備考 大文字／小文字の違いは意味を持たない
	#######全角文字も比較できる
	##値 ##文字がアルファベットであるときは、大文字として扱かっ
	#######た上で、文字をそのアスキーコードで比較し、述語が真な
	#######らば t#それ以外は nil

char-greaterp <character> &rest <characters>
	  組込関数 (p.334 lchar.p)
	  機能 大きいか
	##備考 大文字／小文字の違いは意味を持たない
	#######全角文字も比較できる
	##値 ##文字がアルファベットであるときは、大文字として扱かっ
	#######た上で、文字をそのアスキーコードで比較し、述語が真な
	#######らば t#それ以外は nil

char-not-greaterp <character> &rest <characters>
	  組込関数 (p.334 lchar.p)
	  機能 大きいくないか
	##備考 大文字／小文字の違いは意味を持たない
	#######全角文字も比較できる
	##値 ##文字がアルファベットであるときは、大文字として扱かっ
	#######た上で、文字をそのアスキーコードで比較し、述語が真な
	#######らば t#それ以外は nil

char-int <char>
	  組込関数 (p.335 lchar.p)
	  機能 文字の ASCII#値を取得する
	##値 ##文字の ASCII#値（整数）

char-code <char>
	  組込関数 (p.335 lchar.p)
	  機能 文字の ASCII#値を取得する
	##値 ##文字の ASCII#値（整数）

code-char <code>
	  組込関数 (p.336 lchar.p)
	  機能 文字に変換する（全角文字対応）
	#######引数が文字型の場合そのまま
	#######数値の場合はそのコードの文字
	#######リストの場合は nil
	#######文字列やシンボルの場合は先頭の文字
	##値 ##該当する文字または nil

int-char <integer>
	  組込関数 (p.336 lchar.p)
	  機能 文字に変換する（全角文字対応）
	#######引数が文字型の場合そのまま
	#######数値の場合はそのコードの文字
	#######リストの場合は nil
	#######文字列やシンボルの場合は先頭の文字
	##値 ##該当する文字または nil

character <object>
	  組込関数 (p.336 lchar.p)
	  機能 文字に変換する（全角文字対応）
	#######引数が文字型の場合そのまま
	#######数値の場合はそのコードの文字
	#######リストの場合は nil
	#######文字列やシンボルの場合は先頭の文字
	##値 ##該当する文字または nil

char-upcase <char>
	  組込関数 (p.336 lchar.p)
	  機能 文字を大文字に変換する
	##値 ##該当文字を大文字にしたもの

char-downcase <char>
	  組込関数 (p.336 lchar.p)
	  機能 文字を小文字に変換する
	##値 ##該当文字を小文字にしたもの


digit-char <weight> &optional (radix 10)
	  組込関数 (p.337 lchar.p)
	  機能 数値を基数に応じて数値文字に変換する
	#######アルファベットの場合は常に大文字になる
	##値 ##数値文字または一桁で表現できない場合 nil
	##例###(digit-char 0) → #\0
	#######(digit-char 12) → nil
	#######(digit-char 12 20) → #\C

jis-alpha-p <char>
	  組込関数 (lchar.p)
	  機能 アルファベット（２バイト文字）か？
	##値 ##アルファベットならば t#それ以外は nil

jis-digit-p <char>
	  組込関数 (lchar.p)
	  機能 数字（２バイト文字）か？
	##値 ##数字ならば t#それ以外は nil

jis-hira-p <char>
	  組込関数 (lchar.p)
	  機能 平仮名（２バイト文字）か？
	##値 ##平仮名ならば t#それ以外は nil

jis-kata-p <char>
	  組込関数 (lchar.p)
	  機能 片仮名（２バイト文字）か？
	##値 ##片仮名ならば t#それ以外は nil

jis-kigou-p <char>
	  組込関数 (lchar.p)
	  機能 句読点（２バイト文字）か？
	##値 ##句読点ならば t#それ以外は nil

jis-zen-p <char>
	  組込関数 (lchar.p)
	  機能 ２バイト文字か？
	##値 ##２バイト文字ならば t#それ以外は nil

jis-lower-case-p <char>
	  組込関数 (lchar.p)
	  機能 アルファベット大文字（２バイト）か？
	##値 ##アルファベット大文字ならば t#それ以外は nil

jis-upper-case-p <char>
	  組込関数 (lchar.p)
	  機能 アルファベット小文字（２バイト）か？
	##値 ##アルファベット小文字ならば t#それ以外は nil

jis-space-p <char>
	  組込関数 (lchar.p)
	  機能 ２バイト空白か
	##値 ##２バイト空白ならば t#それ以外は nil

jis-upcase <char>
	  組込関数 (lchar.p)
	  機能 アルファベット小文字（２バイト）であれば大文字にする
	##値 ##アルファベット小文字であれば大文字にして返す

jis-downcase <char>
	  組込関数 (lchar.p)
	  機能 アルファベット大文字（２バイト）であれば小文字にする
	##値 ##アルファベット大文字であれば小文字にして返す

jis-hira-to-kata <char>
	  組込関数 (lchar.p)
	  機能 平仮名（２バイト）であれば片仮名にする
	##値 ##平仮名であれば片仮名にして返す

jis-kata-to-hira <char>
	  組込関数 (lchar.p)
	  機能 片仮名（２バイト）であれば平仮名にする
	##値 ##片仮名であれば平仮名にして返す

han-to-zen <char>
	  組込関数 (lchar.p)
	  機能 半角（１バイト）文字を全角（２バイト）文字にします。
	##備考 数字およびアルファベット蚤を変換します。
	##値 ##引数に対応する全角文字

zen-to-han <char>
	  組込関数 (lchar.p)
	  機能 全角（２バイト）文字を半角（１バイト）文字にします。
	##備考 数字およびアルファベット蚤を変換します。
	##値 ##引数に対応する全角文字

character-to-string <char>
	  組込関数 (lchar.p)
	  機能 文字型を文字列にします
	##値 ##引数に対応する文字列
	##例###(character-to-string #\ あ ") → " あ "


#####［第１４章##列］
#####----------------


elt <sequence> <index>
	  組込関数 (p.345 lseq.p)
	  機能 第１引数中第２引数番目の要素を返す
	#######引数はリストまたはベクタ、文字列
	##値 ##第１引数中第２引数番目の要素を返す
	##例###(elt "0123" 3) → #\3

subseq <sequence> <start> <end>
	  組込関数 (p.345 lseq.p)
	  機能 第１引数中第２引数番目以降第３引数番目までの部分列を
	#######返す
	#######引数はリストまたはベクタ、文字列
	##値 ##第１引数中第２引数番目以降第３引数番目までの部分列
	##例###(subseq #(0 1 2 3) 1 3) → #(1 2 3)

copy-seq <sequence>
	  組込関数 (p.345 lseq.p)
	  機能 リストまたはベクタ、文字列のコピーを返す
	##値 ##引数のコピー

length <sequence>
	  組込関数 (p.345 lseq.p)
	  機能 リストまたはベクタ、文字列の長さを返す
	##値 ##要素数
	##例###(length '(1 2 3)) → 3

reverse <sequence>
	  組込関数 (p.345 lseq.p)
	  機能 リストまたはベクタ、文字列の逆転
	##値 ##要素を逆順に並べた新しいリストまたはベクタ
	##例###(reverse " さかさま ") → " まさかさ "
	#######(reverse '(a b c)) ##→#(c b a)

nreverse <sequence>
	  組込関数 (p.345 lseq.p)
	  機能 リストまたはベクタ、文字列の逆転
	##値 ##要素を逆順に並べたリストまたはベクタ
	##備考 このバージョンでは reverse と同じです

make-sequence <type> <size> <initial-element>
	  組込関数 (p.346 lseq.p)
	  機能 リストまたはベクタ、文字列を生成する
	#######<type>	 list#または cons : リスト
		####charcter#または string : 文字列
		####array : ##配列
	#######<size>	#要素の数
	#######<initial-element> 初期化要素
	##値 ##生成された列
	##例###(make-sequence 'cons 2) → (nil nil)
	  #####(make-sequence 'string 2) → "  "
	#######(make-sequence 'character 3 #\a) → "aaa"
	#######(make-sequence 'array 3 'a) → #(a a a)

concatenate <type> &rest#<sequences>
	  組込関数 (p.346 lseq.p)
	  機能 引数として与えられた列を連結した列を生成する
	#######<type>	 list#または cons : リスト
		####charcter#または string : 文字列
		####array : ##配列
	##値 ##生成された列
	##備考 列になっていない要素は無視されます
	#######文字列の連結では、要素となっている列が全て文字列か文
	#######字でなくてはなりません
	##例###(concatenate 'string '(#\a #\b) "cd")
			#→ "abcd"
	#######(concatenate 'cons '(1 2) "34" #(5 6))
		####→#(1 2 #\3 #\4 5 6)
	#######(concatenate 'array '(a b) " Ｃ " #(d e))
		####→##(a b #\ Ｃ d e)

map <type> <function> <sequence> & <more-sequence>
	  組込関数 (p.346 lseq.p)
	  機能 それぞれの sequence に function を適用した結果を type
	#######の列にする
	#######<type>	 list#または cons : リスト
		####charcter#または string : 文字列
		####array : ##配列
	##値 ##生成された列
	##例###(map 'list##'- '(1 2 3 4))
			#→ (-1 -2 -3 -4)
	  #####(map 'string
		#####'(lambda (x)(if (oddp x) #\1 #\0))
		####'(1 2 3 4))
	#######→ "1010"

some <predicate> <sequence> &rest#<sequence>
	  組込関数 (p.348 lseq.p)
	  機能 <predicate> を <sequence> に適用した結果、nil でない
	#######値があれば、その値を返す
	#######列の終わりに到達すれば、nil を返す
	##備考 <sequence> はリストでなくてはなりません
	#######この関数は暫定版のため、内部で mapcar#を利用している
	#######ので、一度全ての式を評価します

every <predicate> <sequence> &rest#<sequence>
	  組込関数 (p.348 lseq.p)
	  機能 <predicate> を <sequence> に適用した結果、nil があれ
	#######ば、nil を返す
	#######列の終わりに到達すれば、t#を返す
	##備考 <sequence> はリストでなくてはなりません
	#######この関数は暫定版のため、内部で mapcar#を利用している
	#######ので、一度全ての式を評価します

notany <predicate> <sequence> &rest#<sequence>
	  組込関数 (p.348 lseq.p)
	  機能 <predicate> を <sequence> に適用した結果、nil でない
	#######値があれば、nil を返す
	#######列の終わりに到達すれば、t#を返す
	##備考 <sequence> はリストでなくてはなりません
	#######この関数は暫定版のため、内部で mapcar#を利用している
	#######ので、一度全ての式を評価します

notevery <predicate> <sequence> &rest#<sequence>
	  組込関数 (p.348 lseq.p)
	  機能 <predicate> を <sequence> に適用した結果、nil があれ
	#######ば、nil でない値を返す
	#######列の終わりに到達すれば、nil を返す
	##備考 <sequence> はリストでなくてはなりません
	#######この関数は暫定版のため、内部で mapcar#を利用している
	#######ので、一度全ての式を評価します

reduce <function> <sequence>
	  組込関数 (p.348 lseq.p)
	  機能 ２項演算によってリストまたはベクタ、文字列の要素を結
	#######合する
	##値 ##演算結果
	##例###(reduce #'+ '(1 2 3)) → 6
	#######(reduce #'list##(a b c d)) → (((a b) c) d)

reduce* <function> &rest#<objects>
	  組込関数 (lseq.p)
	  機能 ２項演算によって引数要素を結合する
	##値 ##演算結果
	##例###(reduce* #'+ '1 '2 '3) → 6
	#######(reduce* #'list#'a b c 'd)) → (((a unk) unk) d)

fill <sequence> <item> &optional <start> <end>
	  組込関数 (p.349 lseq.p)
	  機能 リストまたはベクタの修正
	#######<seqyence> 変更されるリストまたはベクタ
	#######<item>	##置き換える内容
	#######<start>	  開始位置（既定値はゼロ）
	#######<end>	  終了位置（既定値は列の長さ）
	##値 ##修正されたリストまたはベクタ、文字列
	##備考 <end>#の位置指定は指定された場所自身を含まない
	#######現状、引数がリストまたは文字列の場合、もとの列を破壊
	#######しません
	##例###(fill #(a b c d) 'x 1 3)#→##(a x x d)
	#######(fill '(a b c d) 'x) → (x x x x)
	#######(fill "abcdefgh" '#\ Ｘ 2 5) → "ab ＸＸＸ fgh"

remove <item> <sequence>
	  組込関数 (p.350 lseq.p)
	  機能 リストまたはベクタ、文字列である <sequence> から#<item
	#######> を除く
	##値 ##<sequence> から#<item> を除いたものを返す
	##例###(remove '4#'(1 2 3 4 4 2)) → (1 2 3 2)
	  #####(remove 'a #(a b c d s a))#→##(b c d s))
	#######(remove '#\ た " ぬたきた ")##→ " ぬき "

remove-if <predicate> <sequence>
	  組込関数 (p.350 lseq.p)
	  機能 リストまたはベクタ、文字列である <sequence> から関数
	#######<predicate> を適用すると真になるものを除く
	##値 ##<sequence> から#<predicate> を適用して真になるものを
	#######除いたものを返す

remove-if-not <predicate> <sequence>
	  組込関数 (p.350 lseq.p)
	  機能 リストまたはベクタ、文字列である <sequence> から
	#######関数 <predicate> を適用すると偽になるものを除く
	##値 ##<sequence> から#<predicate> を適用して偽になるものを
	#######除いたものを返す

delete <item> <sequence>
	  組込関数 (p.350 lseq.p)
	  機能 リストまたはベクタ、文字列である <sequence> から#<item
	#######> を除く
	##値 ##<sequence> から#<item> を除いたものを返す
	##備考 現状 remove と同じ

delete-if <predicate> <sequence>
	  組込関数 (p.350 lseq.p)
	  機能 リストまたはベクタ、文字列である <sequence> から関数
	#######<predicate> を適用すると真になるものを除く
	##値 ##<sequence> から#<predicate> を適用して真になるものを
	#######除いたものを返す
	##備考 現状 remove-if と同じ

delete-if-not <predicate> <sequence>
	  組込関数 (p.350 lseq.p)
	  機能 リストまたはベクタ、文字列である <sequence> から関数
	#######<predicate> を適用すると偽になるものを除く
	##値 ##<sequence> から#<predicate> を適用して偽になるものを
	#######除いたものを返す
	##備考 現状 remove-if-not と同じ

remove-duplicates <sequence>
	  組込関数 (p.352 lseq.p)
	  機能 リストまたはベクタ、文字列である <sequence> から重複
	#######している要素を除く
	##値 ##<sequence> から重複した要素を除いたものを返す

delete-duplicates <sequence>
	  組込関数 (p.352 lseq.p)
	  機能 リストまたはベクタ、文字列である <sequence> から重複
	#######している要素を除く
	##値 ##<sequence> から重複した要素を除いたものを返す

substitute <newitem> <olditem> <sequence>
	  組込関数 (p.353 lseq.p)
	  機能 リストまたはベクタ、文字列である <sequence>#のうち、<
	#######olditem> を <newitem> に置き換える
	##値 ##<sequence> 中の <olditem> を <newitem> に置き換えたも
	#######の

substitute-if <newitem> <predicate> <sequence>
	  組込関数 (p.353 lseq.p)
	  機能 リストまたはベクタ、文字列である <sequence>#のうち、
	#######関数 <predicate> を適用すると真となる要素を <newitem>
	#######に置き換える
	##値 ##概要箇所を <newitem> に置き換えたもの

substitute-if-not <newitem> <predicate> <sequence>
	  組込関数 (p.353 lseq.p)
	  機能 リストまたはベクタ、文字列である <sequence>#のうち、
	#######関数 <predicate> を適用すると偽となる要素を <newitem>
	#######に置き換える
	##値 ##概要箇所を <newitem> に置き換えたもの

nsubstitute <newitem> <olditem> <sequence>
	  組込関数 (p.353 lseq.p)
	  機能 リストまたはベクタ、文字列である <sequence>#のうち、<
	#######olditem> を <newitem> に置き換える
	##値 ##<sequence> 中の <olditem> を <newitem> に置き換えたも
	#######の

nsubstitute-if <newitem> <predicate> <sequence>
	  組込関数 (p.353 lseq.p)
	  機能 リストまたはベクタ、文字列である <sequence>#のうち、
	#######関数 <predicate> を適用すると真となる要素を <newitem>
	#######に置き換える
	##値 ##概要箇所を <newitem> に置き換えたもの

nsubstitute-if-not <newitem> <predicate> <sequence>
	  組込関数 (p.353 lseq.p)
	  機能 リストまたはベクタ、文字列である <sequence>#のうち、
	#######関数 <predicate> を適用すると偽となる要素を <newitem>
	#######に置き換える
	##値 ##概要箇所を <newitem> に置き換えたもの

find <item> <sequence>
	  組込関数 (p.354 lseq.p)
	  機能 リストまたはベクタ、文字列中に#<item> と等しい (equal)
	  #####要素を探す
	##値 ##等しい要素があれば、その要素#<item> を、なければ nil
	#######を返す

find-if <predicate> <sequence>
	  組込関数 (p.354 lseq.p)
	  機能 リストまたはベクタ、文字列中に#<predicate> を適用する
	#######と真となる要素を探す
	##値 ##真となる要素があれば、その要素を、なければ nil#を返す

find-if-not <predicate> <sequence>
	  組込関数 (p.354 lseq.p)
	  機能 リストまたはベクタ、文字列中に#<predicate> を適用する
	#######と偽となる要素を探す
	##値 ##偽となる要素があれば、その要素を、なければ nil#を返す

position <item> <sequence>
	  組込関数 (p.354 lseq.p)
	  機能 リストまたはベクタ、文字列の中に#<item> と同じ要素を
	  #####探す
	##値 ##同じ要素があれば、その位置を、なければ nil#を返す
	##備考 最も先頭に近い要素の位置（文字単位）が返ります

position-if  <predicate> <sequence>
	  組込関数 (p.354 lseq.p)
	  機能 リストまたはベクタ、文字列の中に#<predicate> を適用す
	#######ると真になる要素を探す
	##値 ##真となる要素があれば、その位置を、なければ nil#を返す
	##備考 最も先頭に近い要素の位置（文字単位）が返ります

position-if-not  <predicate> <sequence>
	  組込関数 (p.354 lseq.p)
	  機能 リストまたはベクタ、文字列の中に#<predicate> を適用す
	#######ると偽になる要素を探す
	##値 ##偽となる要素があれば、その位置を、なければ nil#を返す
	##備考 最も先頭に近い要素の位置（文字単位）が返ります

count <item> <sequence>
	  組込関数 (p.354 lseq.p)
	  機能 リストまたはベクタ、文字列の中に#<item> と同じ要素を
	  #####数える
	##値 ##同じ要素の個数を返す

count-if  <predicate> <sequence>
	  組込関数 (p.354 lseq.p)
	  機能 リストまたはベクタ、文字列の中に#<predicate> を適用す
	#######ると真になる要素を数える
	##値 ##真となる要素の個数を返す

count-if-not  <predicate> <sequence>
	  組込関数 (p.354 lseq.p)
	  機能 リストまたはベクタ、文字列の中に#<predicate> を適用す
	#######ると偽になる要素を数える
	##値 ##偽となる要素の個数を返す

sort <sequence>#<predicate>
	  組込関数 (p.357 lseq.p)
	  機能 リストまたはベクタ、文字列を <predicate> でソートする
	##値 ##ソートした結果
	##備考 非安定的にソートされます ( クイックソートを使用 )
	  #####<predicate> は必ず２引数関数であり、２つの引数が一致
	#######する場合は nil#を返すものでなくてはなりません。
	#######それが満たされない場合は、値が帰ってこないことがあり
	  #####得ます。
	##例###(sort '(9 2 3 5 1) '>) → (9 5 3 2 1)
	  #####(sort #(#\g #\f #\y #\p #\v)
		  ###'(lambda (x y) (< (char-code x) (char-code y)))))
	#######→ #(#\f #\g #\p #\v #\y)


#####［第１５章##リスト］
#####--------------------


car <list>
	  組込関数 (p.361 llist.p)
	  機能 リストの car 部取得
	##備考 *car-of-nil* が nil#の場合、(car nil) がエラーになり
	  #####ます。
	##値 ##リストの car 部
	#######引数がリストでなければ、nil#を返す。

cdr <list>
	  組込関数 (p.361 llist.p)
	  機能 リストの cdr 部取得
	##値 ##リストの cdr 部
	#######引数がリストでなければ、nil#を返す。

caar <list>
	  組込関数 (p.362 llist.p)
	  機能 リストの caar 部取得
	##値 ##リストの caar 部

cadr <list>
	  組込関数 (p.362 llist.p)
	  機能 リストの cadr 部取得
	##値 ##リストの cadr 部

cdar <list>
	  組込関数 (p.362 llist.p)
	  機能 リストの cdar 部取得
	##値 ##リストの cdar 部

cddr <list>
	  組込関数 (p.362 llist.p)
	  機能 リストの cddr 部取得
	##値 ##リストの cddr 部

caaar <list>
	  組込関数 (p.362 llist.p)
	  機能 リストの caaar 部取得
	##値 ##リストの caaar 部

caadr <list>
	  組込関数 (p.362 llist.p)
	  機能 リストの caadr 部取得
	##値 ##リストの caadr 部

cadar <list>
	  組込関数 (p.362 llist.p)
	  機能 リストの cadar 部取得
	##値 ##リストの cadar 部

caddr <list>
	  組込関数 (p.362 llist.p)
	  機能 リストの caddr 部取得
	##値 ##リストの caddr 部

cdaar <list>
	  組込関数 (p.362 llist.p)
	  機能 リストの cdaar 部取得
	##値 ##リストの cdaar 部

cdadr <list>
	  組込関数 (p.362 llist.p)
	  機能 リストの cdadr 部取得
	##値 ##リストの cdadr 部

cddar <list>
	  組込関数 (p.362 llist.p)
	  機能 リストの cddar 部取得
	##値 ##リストの cddar 部

cdddr <list>
	  組込関数 (p.362 llist.p)
	  機能 リストの cdddr 部取得
	##値 ##リストの cdddr 部

caaaar <list>
	  組込関数 (p.362 llist.p)
	  機能 リストの caaaar 部取得
	##値 ##リストの caaaar 部

caaadr <list>
	  組込関数 (p.362 llist.p)
	  機能 リストの caaadr 部取得
	##値 ##リストの caaadr 部

caadar <list>
	  組込関数 (p.362 llist.p)
	  機能 リストの caadar 部取得
	##値 ##リストの caadar 部

caaddr <list>
	  組込関数 (p.362 llist.p)
	  機能 リストの caaddr 部取得
	##値 ##リストの caaddr 部

cadaar <list>
	  組込関数 (p.362 llist.p)
	  機能 リストの cadaar 部取得
	##値 ##リストの cadaar 部

cadadr <list>
	  組込関数 (p.362 llist.p)
	  機能 リストの cadadr 部取得
	##値 ##リストの cadadr 部

caddar <list>
	  組込関数 (p.362 llist.p)
	  機能 リストの caddar 部取得
	##値 ##リストの caddar 部

cadddr <list>
	  組込関数 (p.362 llist.p)
	  機能 リストの cadddr 部取得
	##値 ##リストの cadddr 部

cdaaar <list>
	  組込関数 (p.362 llist.p)
	  機能 リストの cdaaar 部取得
	##値 ##リストの cdaaar 部

cdaadr <list>
	  組込関数 (p.362 llist.p)
	  機能 リストの cdaadr 部取得
	##値 ##リストの cdaadr 部

cdadar <list>
	  組込関数 (p.362 llist.p)
	  機能 リストの cdadar 部取得
	##値 ##リストの cdadar 部

cdaddr <list>
	  組込関数 (p.362 llist.p)
	  機能 リストの cdaddr 部取得
	##値 ##リストの cdaddr 部

cddaar <list>
	  組込関数 (p.362 llist.p)
	  機能 リストの cddaar 部取得
	##値 ##リストの cddaar 部

cddadr <list>
	  組込関数 (p.362 llist.p)
	  機能 リストの cddadr 部取得
	##値 ##リストの cddadr 部

cdddar <list>
	  組込関数 (p.362 llist.p)
	  機能 リストの cdddar 部取得
	##値 ##リストの cdddar 部

cddddr <list>
	  組込関数 (p.362 llist.p)
	  機能 リストの cddddr 部取得
	##値 ##リストの cddddr 部

cons <x>#<y>
	  組込関数 (p.361 llist.p)
	  機能 新しいコンスの生成
	  #####<x>##リストの car となるもの
	  #####<y>##リストの cdr となるもの
	  値 ##生成されたコンス

endp <object>
	  組込関数 (p.361 llist.p)
	  機能 リストの終わりか？
	##備考 リスト以外の場合は ＸＬＩＳＰ では nil#だが、λογο
	#######σ ではコモンリスプに準じエラー
	##値 ##nil#ならば t コンスならば nil

list-length <list>
	  ユーザー関数 (p.364 init.lsp)
	  機能 リストの長さを返す（循環リスト対応）
	##値 ##リストが有限ならば、リストの長さを、リストが循環てい
	  #####れば、nil#を返す

nth <n>#<list>
	  組込関数 (p.364 llist.p)
	  機能 リストの n 番目の要素の取得
	#######<n># 取得したい要素の位置（ゼロ開始）
	#######<list>	#リスト
	##値 ##n 番目のリストの要素（リストが短い場合には nil#）

first#<list>
	  組込関数 (p.365 llist.p)
	  機能 car と同義
	##値 ##リストの１番目の要素を取り出す

second#<list>
	  組込関数 (p.365 llist.p)
	  機能 cadr と同義
	##値 ##リストの２番目の要素を取り出す

third#<list>
	  組込関数 (p.365 llist.p)
	  機能 caddr と同義
	##値 ##リストの３番目の要素を取り出す

fourth <list>
	  組込関数 (p.365 llist.p)
	  機能 cadddr と同義
	##値 ##リストの４番目の要素を取り出す

fifth <list>
	  組込関数 (p.365 llist.p)
	  機能 caddddr と同義
	##値 ##リストの５番目の要素を取り出す

sixth <list>
	  組込関数 (p.365 llist.p)
	  機能 cadddddr と同義
	##値 ##リストの６番目の要素を取り出す

seventh <list>
	  組込関数 (p.365 llist.p)
	  機能 caddddddr と同義
	##値 ##リストの７番目の要素を取り出す

eighth <list>
	  組込関数 (p.365 llist.p)
	  機能 cadddddddr と同義
	##値 ##リストの８番目の要素を取り出す

nineth <list>
	  組込関数 (p.365 llist.p)
	  機能 caddddddddr と同義
	##値 ##リストの９番目の要素を取り出す

tenth <list>
	  組込関数 (p.365 llist.p)
	  機能 cadddddddddr と同義
	##値 ##リストの１０番目の要素を取り出す

rest#<list>
	  組込関数 (p.365 llist.p)
	  機能 cdr と同義
	##値 ##リストの１番目を除いたものを返す

nthcdr <n>#<list>
	  組込関数 (p.364 llist.p)
	  機能 リストの n 番目の cdr の取得
	#######<n># 取得したい要素の位置（ゼロ開始）
	#######<list>	#リスト
	##値 ##n 番目の cdr （リストが短い場合には nil#）

last#<list>
	  組込関数 (p.366 llist.p)
	  機能 リストの最終要素を取得
	##備考 第二引数はありません
	##値 ##リストの最終要素

lastelem#<list>
	  組込関数 (llist.p)
	  機能 リストの最終要素を取得
	##値 ##リストの最終要素

list &rest#<args>
	  組込関数 (p.367 llist.p)
	  機能 リストの生成
	  値 ##生成されたリスト

list* arg &rest#<others>
	  組込関数 (p.367 llist.p)
	  機能 リストの生成
	  値 ##生成されたリスト（最後の要素が最後の cons の cdr にな
	  #####る）
	##例###(list* 1) → 1
	#######(list* 1 2 3)  → (1 2 . 3)

make-list <size>#<initial-element>
	  組込関数 (p.367 llist.p)
	  機能 size 個の initial-element#を持つリストを作る
	  値 ##生成されたリスト
	##備考 コモンリスプと違いキーワード指定の必要はない
	  例###(make-list 0)  → ##nil
	#######(make-list 2)  → ##(nil#nil)
	  #####(make-list 3 'a) →  (a a a)

append &rest#lists
	  組込関数 (p.367 llist.p)
	  機能 リストの結合
	  値 ##生成されたリスト

append2#<list1>#<list2>
	  組込関数 (p.367 llist.p)
	  機能 リストの結合（２引数）
	##値 ##生成されたリスト

revappend <x>#<y>
	  組込関数 (p.367 llist.p)
	  機能 逆順にしたリストを結合する
	  値 ##逆順にされたものを結合したリスト

nconc &rest#<lists>
	  組込関数 (p.368 llist.p)
	  機能 破壊型リスト連結
	  値 ##連結されたリスト

nconc2#<list1>#<list2>
	  組込関数 (p.368 llist.p)
	  機能 ２引数の破壊型リスト連結
	  値 ##連結されたリスト

butlast#<list> &optional#<n>
	  組込関数 (p.371 llist.p)
	  機能 リストの後ろから n 要素を除いたリストを生成する
	  #####引数リストは破壊されない
	  #####n#を省略すると#n#を１とみなす
	  値 ##後ろから n 要素を除いたリスト

nbutlast#<list> &optional#<n>
	  組込関数 (p.371 llist.p)
	  機能 リストの後ろから n 要素を除いたリストを生成する
	  #####n#を省略すると#n#を１とみなす
	  値 ##後ろから n 要素を除いたリスト

ldiff#<list> <sublist>!
	  組込関数 (p.372 llist.p)
	  機能 <sublist> が#<list> の部分リストであれば、その部分リ
	#######ストより前の部分を得る
	  値 ##部分リストであればその部分リストの前の部分、そうでな
	  #####ければリストそのもの
	##備考 部分リストかどうかの判定には eq#を使用しています

rplaca <x>#<y>
	  組込関数 (p.372 llist.p)
	  機能 リストの car を置換する
	  #####<x>##リスト
	#######<y>##リストの car の新しい値
	##値 ##car を更新した後のリスト

rplacd <x>#<y>
	  組込関数 (p.372 llist.p)
	  機能 リストの cdr を置換する
	  #####<x>##リスト
	#######<y>##リストの cdr の新しい値
	##値 ##cdr を更新した後のリスト

subst#<new> <old> <tree>
	  組込関数 (p.373 llist.p)
	  機能 式の置換
	#######<new>  新しく置換する要素
	#######<old>  置換される要素
	#######<tree> 元となるＳ式
	  値 ##Ｓ式#<tree> の要素のうち、全ての <old> を#<new> に
	#######置き換えたものを返す
	  例###(subst	 '#スキー
		####' 水泳
		####'( いつも 水泳 の時期には 水泳 をします。
			 ( 水泳 の用意を忘れずに！ )))
	  #####→ ##( いつも スキー の時期には スキー をします。
			 ( スキー の用意を忘れずに！ ))

subst-if#<new> <pred> <tree>
	  組込関数 (p.373 llist.p)
	  機能 式の置換
	#######<new>  新しく置換する要素
	#######<pred> 述語
	#######<tree> 元となるＳ式
	  値 ##Ｓ式#<tree> の要素のうち、<pred> を満たすもの > を#<
	  #####new> に置き換えたものを返す
	  例###(subst-if#'! 'numberp#'(1 2 c d (6 7)))
	  #####→ ##(! ! c d (! !))

subst-if-not#<new> <pred> <tree>
	  組込関数 (p.373 llist.p)
	  機能 式の置換
	#######<new>  新しく置換する要素
	#######<pred> 述語
	#######<tree> 元となるＳ式
	  値 ##Ｓ式#<tree> の要素のうち、<pred> を満たさないもの >
	  #####を#<new> に置き換えたものを
	#######返す
	  例###(subst-if-not#'! 'numberp#'(1 2 c d (6 7)))
	  #####→ ##(1 2 ! ! (6 7 . !) . !)

sublis#<alist> <tree>
	  組込関数 (p.374 llist.p)
	  機能 連想リストによる式の置換
	#######<alist>	置換される要素と置換する要素からなる
		#### 連想リスト
	#######<tree> 元となるＳ式
	  値 ##Ｓ式#<tree> の要素のうち、連想リストによって置き換え
	  #####たものを返す
	  例###(sublis#'(( x . 100)(y . 10))
		####'(x y x (x y z)))
	  #####→ #(100 10 100#(100 10 z))

member#<item>#<list>
	  組込関数 (p.375 llist.p)
	  機能 リストの検索（equal#による検索）
	#######<item># 検索する式
	  #####<list>  検索対象のリスト
	  値 ##検索する式を先頭にしたリストの残り部分

member-if#<predicate>#<list>
	  組込関数 (p.375 llist.p)
	  機能 リストの検索
	#######<predicate>#検査する式
	  #####<list>	###検索対象のリスト
	  値 ##検査する式を満たす要素を先頭にしたリストの残り部分

member-if-not#<predicate>#<list>
	  組込関数 (p.375 llist.p)
	  機能 リストの検索
	#######<predicate>#検査する式
	  #####<list>	###検索対象のリスト
	  値 ##検査する式を満たさない要素を先頭にしたリストの残り部
	#######分

memq#<item>#<list>
	  組込関数 (llist.p)
	  機能 リストの検索（eq#による検索）
	#######<item># 検索する式
	  #####<list>  検索対象のリスト
	  値 ##検索する式を先頭にしたリストの残り部分

tailp <sublist> <list>
	  組込関数 (p.376 llist.p)
	  機能 <sublist> が#<list> の部分リストかどうか
	  値 ##部分リストであれば t そうでなければ nil
	##備考 <sublist> は nil であってもエラーになりません
	#######部分リストかどうかの判定には eq#を使用しています

adjoin#<item>#<list>
	  組込関数 (p.376 llist.p)
	  機能 集合に要素を加える
	  値 ##集合に要素を加えたもの
	  #####すでに要素が集合の中にあれあば元の集合を返す

union#<list1>#<list2>
	  組込関数 (p.377 llist.p)
	  機能 ２つの集合の全ての要素を含む集合を返す
	  値 ##２つの集合の全ての要素を含むリスト

intersection#<list1>#<list2>
	  組込関数 (p.378 llist.p)
	  機能 ２つの集合に共通する要素の集合を返す
	  値 ##２つの集合に共通する要素のリスト

set-difference#<list1>#<list2>
	  組込関数 (p.378 llist.p)
	  機能 <list2> の要素に含まれない#<list1>#の要素のリストを返
	  #####す
	##値 ##<list2> の要素に含まれない#<list1>#の要素のリスト

set-exclusive-or#<list1>#<list2>
	  組込関数 (p.379 llist.p)
	  機能 <list1>#と <list2> の両方にちょうど１つだけ現れている
	  #####要素のリストを返す
	##値 ##<list1>#と <list2> の両方にちょうど１つだけ現れている
	  #####要素のリスト

subsetp <list1>#<list2>
	  組込関数 (p.380 llist.p)
	  機能 <list1>#の全ての要素が#<list2> に現れるか
	  値 ##<list1>#の要素が全て <list2> の要素に含まれれば t
	  #####そうでなければ nil#を返す

acons#<key>#<datum>#<a-list>
	  組込関数 (p.380 llist.p)
	  機能 対 (key . datum)#を#a-list に付け加える
	  値 ##新しい#a-list
	##備考 (cons#(cons#key datum)#a-list)#と同じ

pairlis#<keys>#<data> &optional#<a-list>
	  組込関数 (p.380 llist.p)
	  機能 <keys>#と <data> から新しい連想リストを作り、<a-list>
	  #####の頭に加える
	  値 ##新しい#a-list

assoc#<item>#<a-list>
	  組込関数 (p.381 llist.p)
	  機能 連想リスト (key)#の検索（eql で比較）
	#######<item>	###検索する式（car#部分で検索）
	#######<a-list>  検索対象の連想リスト
	##値 ##連想リストのノードまたは nil

assoc-if#<predicate>#<a-list>
	  組込関数 (p.381 llist.p)
	  機能 連想リスト (key)#の検索
	#######<predicate>#検査する式（連想リストの car#部分を検査）
	#######<a-list>    検索対象の連想リスト
	##値 ##連想リストのノードで検査をみたしたものまたは nil

assoc-if-not#<predicate>#<a-list>
	  組込関数 (p.381 llist.p)
	  機能 連想リスト (key)#の検索
	#######<predicate>#検査する式（連想リストの car#部分を検査）
	#######<a-list>    検索対象の連想リスト
	##値 ##連想リストのノードで検査をみたしたさないものまたは nil

rassoc#<item>#<a-list>
	  組込関数 (p.382 llist.p)
	  機能 連想リスト (datum)#の検索（eql で比較）
	#######<item>	###検索する式（cdr#部分で検索）
	#######<a-list>  検索対象の連想リスト
	##値 ##連想リストのノードまたは nil

rassoc-if#<predicate>#<a-list>
	  組込関数 (p.381 llist.p)
	  機能 連想リスト (key)#の検索
	#######<predicate>#検査する式（連想リストの cdr#部分を検査）
	#######<a-list>    検索対象の連想リスト
	##値 ##連想リストのノードで検査をみたしたものまたは nil

rassoc-if-not#<predicate>#<a-list>
	  組込関数 (p.381 llist.p)
	  機能 連想リスト (key)#の検索
	#######<predicate>#検査する式（連想リストの cdr#部分を検査）
	#######<a-list>    検索対象の連想リスト
	##値 ##連想リストのノードで検査をみたしたさないものまたは nil



#####［第１７章##配列］
#####------------------


vector#&rest <objects>
	  組込関数 (p.393 larray.p)
	  機能 リストからのベクタの生成
	##値 ##引数リストを初期値としたベクタを返す
	  例###(vector#1 2 3) → #(1 2 3)

list-to-vector#<objects>
	  組込関数 (larray.p)
	  機能 リストからのベクタの生成
	##値 ##引数リストを初期値としたベクタを返す
	  備考 vector#と違い１引数関数です
	  例###(list-to-vector#'(1 2 3)) → #(1 2 3)

vector-to-list <objects>
	  組込関数 (larray.p)
	  機能 ベクタからのリストの生成
	##値 ##引数ベクタをリストに変換したものを返す
	  例###(vector-to-list #(1 2 3)) → (1 2 3)

string-to-vector#<string>
	  組込関数 (larray.p)
	  機能 文字列からのベクタの生成
	##値 ##引数文字列を初期値としたベクタを返す
	  例###(string-to-vector#"123")
			 → #(#\1 #\2 #\3)
	#######(string-to-vector#" Ａ b Ｃ ")
			 → #(#\ Ａ #\b #\ Ｃ )

vector-to-string <objects>
	  組込関数 (larray.p)
	  機能 ベクタからの文字列の生成
	##値 ##引数ベクタを文字列に変換したものを返す
	  例###(vector-to-string #(#\1 #\2 #\3))
		#####→#"123"
	#######(vector-to-string #(#\ Ａ #\b #\ Ｃ ))
		#####→#" Ａ b Ｃ "

aref#<array> &rest <subscripts>
	  組込関数 (p.393 larray.p)
	  機能 ベクタの要素を取り出す
	  値 ##第２引数番目の要素を返す（ゼロ開始）
	##備考 現在１次元配列のみ対応のため、svref#と同じ

svref#<vector>#<subscripts>
	  組込関数 (p.393 larray.p)
	  機能 ベクタの要素を取り出す
	  値 ##第２引数番目の要素を返す（ゼロ開始）
	  例###(svref##(a b c) 2) → c

set-vector#<vector>#<subscripts> <object>
	  組込関数 (larray.p)
	  機能 ベクタの要素を書き換える
	  値 ##書き換えられたベクタを返す
	  例###(set-vector#(vector#'a 'b 'c) 0 '!)
			 → #(! b c)

array-element-type#<array>
	  組込関数 (p.394 larray.p)
	  機能 配列（現状ベクタのみ）の要素の型を得る
	  値 ##配列の要素の型を返す（現状常に unk）

array-rank#<array>
	  組込関数 (p.394 larray.p)
	  機能 配列（現状ベクタのみ）の次元数を得る
	  値 ##配列の次元数を返す（現状常に１）

array-dimension#<array>
	  組込関数 (p.394 larray.p)
	  機能 配列（現状ベクタのみ）の要素数を得る
	  値 ##配列の要素数を返す
	  備考 要素数なので、位置指定の関数とは違い、ゼロ開始で
	  #####はありません
	  例###(array-dimension##(1 2)) → 2

vector-equal#<array> <array>
	  組込関数 (larray.p)
	  機能 等しいベクタか？
	  値 ##等しければ t#等しくなければ nil


#####［第１８章##文字列］
#####--------------------


char#<string>#<index>
	  組込関数 (p.406 lstring.p)
	  機能 文字列またはシンボルから１文字取り出す
	  #####<string># 文字列またはシンボル
	#######<index>	###インデックス（ゼロ開始）
	##値 ##文字（文字型）
	  例###(char#"abc" 1)	 → #\b
	#######(char#" ＦＡＩ ")###→##\ Ｆ
	#######(char#" ＦＡＩ " 2) → #\ Ｉ
	#######(char#"a Ｂ C" 2) ##→##\C
	  備考 全角文字も１文字として数えます

string-length#<string>
	  組込関数 (lstring.p)
	  機能 文字列またはシンボルの長さ（文字単位）を求める
	  値 ##文字列の長さ（ゼロ開始）
	  例###(string-length#"")##→ 0
	#######(string-length#"a")#→ 1
	#######(string-length#" λ計算 ")#→ 3
	#######(string-length#"abc 順 ")##→ 4
	  備考 全角文字も１文字として数えます

string-byte-length#<string>
	  組込関数 (lstring.p)
	  機能 文字列またはシンボルの長さ（バイト単位）を求める
	  値 ##文字列の長さ（ゼロ開始）
	  例###(string-byte-length#"")	#####→#0
	#######(string-byte-length#"a")#→ 1
	#######(string-byte-length#" λ計算 ")	 → 6
	#######(string-byte-length#"abc 順 ")##→ 5
	  備考 全角文字は２バイトとして数えます

string-character-position-to-byte-position#<string>#<position>
	  組込関数 (lstring.p)
	  機能 文字列中またはシンボル中の位置を文字単位からバイト単
	  #####位に変換する
	  値 ##文字列の位置（ゼロ開始）
	  例###(string-character-position-to-byte-position
		#####"" 1)
			 → nil
	#######(string-character-position-to-byte-position
		####"a" 0)
			 → 0
	#######(string-character-position-to-byte-position
		####" λ計算 " 2)
			 → 4
	  #####(string-character-position-to-byte-position
		####"abc 順 " 3)
			 → 3

string-byte-position-to-character-position#<string>#<position>
	  組込関数 (lstring.p)
	  機能 文字列中またはシンボル中の位置をバイト単位から文字単
	  #####位に変換する
	  値 ##文字列の位置（ゼロ開始）
	  例###(string-byte-position-to-character-position
		####"" 1)
			 → nil
	#######(string-byte-position-to-character-position
		####"a" 0)
			 → 0
	#######(string-byte-position-to-character-position
		####" λ計算 " 2)
			 → 1
	#######(string-byte-position-to-character-position
		####"abc 順 " 3)
			 → 3

string=##<str1>#<str2>
	  組込関数 (p.406-407 lstring.p)
	  機能 文字列またはシンボルの比較
	  #####<str1>	#比較する文字列１
	  #####<str2>	#比較する文字列２
	  値 ##述語が真ならば t#それ以外は nil
	##備考 大文字／小文字の違いは意味を持つ
	  #####全角文字混じりの場合、そのまま順にアスキーコードで比
	  #####較する

string==#<str1>#<str2>
	  組込関数 (p.406-407 lstring.p)
	  機能 文字列またはシンボルの比較
	  #####<str1>	#比較する文字列１
	  #####<str2>	#比較する文字列２
	  値 ##述語が真ならば t#それ以外は nil
	##備考 大文字／小文字の違いは意味を持つ
	  #####全角文字混じりの場合、そのまま順にアスキーコードで比
	  #####較する

string<##<str1>#<str2>
	  組込関数 (p.406-407 lstring.p)
	  機能 文字列またはシンボルの比較
	  #####<str1>	#比較する文字列１
	  #####<str2>	#比較する文字列２
	  値 ##述語が真ならば t#それ以外は nil
	##備考 大文字／小文字の違いは意味を持つ
	  #####全角文字混じりの場合、そのまま順にアスキーコードで比
	  #####較する

string<=#<str1>#<str2>
	  組込関数 (p.406-407 lstring.p)
	  機能 文字列またはシンボルの比較
	  #####<str1>	#比較する文字列１
	  #####<str2>	#比較する文字列２
	  値 ##述語が真ならば t#それ以外は nil
	##備考 大文字／小文字の違いは意味を持つ
	  #####全角文字混じりの場合、そのまま順にアスキーコードで比
	  #####較する

string=<#<str1>#<str2>
	  組込関数 (p.406-407 lstring.p)
	  機能 文字列またはシンボルの比較
	  #####<str1>	#比較する文字列１
	  #####<str2>	#比較する文字列２
	  値 ##述語が真ならば t#それ以外は nil
	##備考 大文字／小文字の違いは意味を持つ
	  #####全角文字混じりの場合、そのまま順にアスキーコードで比
	  #####較する

string>=#<str1>#<str2>
	  組込関数 (p.406-407 lstring.p)
	  機能 文字列またはシンボルの比較
	  #####<str1>	#比較する文字列１
	  #####<str2>	#比較する文字列２
	  値 ##述語が真ならば t#それ以外は nil
	##備考 大文字／小文字の違いは意味を持つ
	  #####全角文字混じりの場合、そのまま順にアスキーコードで比
	  #####較する

string=>#<str1>#<str2>
	  組込関数 (p.406-407 lstring.p)
	  機能 文字列またはシンボルの比較
	  #####<str1>	#比較する文字列１
	  #####<str2>	#比較する文字列２
	  値 ##述語が真ならば t#それ以外は nil
	##備考 大文字／小文字の違いは意味を持つ
	  #####全角文字混じりの場合、そのまま順にアスキーコードで比
	  #####較する

string>##<str1>#<str2>
	  組込関数 (p.406-407 lstring.p)
	  機能 文字列またはシンボルの比較
	  #####<str1>	#比較する文字列１
	  #####<str2>	#比較する文字列２
	  値 ##述語が真ならば t#それ以外は nil
	##備考 大文字／小文字の違いは意味を持つ
	  #####全角文字混じりの場合、そのまま順にアスキーコードで比
	  #####較する

string/=#<str1>#<str2>
	  組込関数 (p.406-407 lstring.p)
	  機能 文字列またはシンボルの比較
	  #####<str1>	#比較する文字列１
	  #####<str2>	#比較する文字列２
	  値 ##述語が真ならば t#それ以外は nil
	##備考 大文字／小文字の違いは意味を持つ
	  #####全角文字混じりの場合、そのまま順にアスキーコードで比
	  #####較する

string!=#<str1>#<str2>
	  組込関数 (p.406-407 lstring.p)
	  機能 文字列またはシンボルの比較
	  #####<str1>	#比較する文字列１
	  #####<str2>	#比較する文字列２
	  値 ##述語が真ならば t#それ以外は nil
	##備考 大文字／小文字の違いは意味を持つ
	  #####全角文字混じりの場合、そのまま順にアスキーコードで比
	  #####較する

string-equal#<str1>#<str2>
	  組込関数 (p.408 lstring.p)
	  機能 文字列またはシンボルの比較
	  #####<str1>	#比較する文字列１
	  #####<str2>	#比較する文字列２
	  値 ##述語が真ならば t#それ以外は nil
	##備考 大文字／小文字の違いは意味を持たない

string-lessp#<str1>#<str2>
	  組込関数 (p.408 lstring.p)
	  機能 文字列またはシンボルの比較
	  #####<str1>	#比較する文字列１
	  #####<str2>	#比較する文字列２
	  値 ##述語が真ならば t#それ以外は nil
	##備考 大文字／小文字の違いは意味を持たない

string-not-greaterp#<str1>#<str2>
	  組込関数 (p.408 lstring.p)
	  機能 文字列またはシンボルの比較
	  #####<str1>	#比較する文字列１
	  #####<str2>	#比較する文字列２
	  値 ##述語が真ならば t#それ以外は nil
	##備考 大文字／小文字の違いは意味を持たない

string-equalp#<str1>#<str2>
	  組込関数 (p.408 lstring.p)
	  機能 文字列またはシンボルの比較
	  #####<str1>	#比較する文字列１
	  #####<str2>	#比較する文字列２
	  値 ##述語が真ならば t#それ以外は nil
	##備考 大文字／小文字の違いは意味を持たない

string-not-equalp#<str1>#<str2>
	  組込関数 (p.408 lstring.p)
	  機能 文字列またはシンボルの比較
	  #####<str1>	#比較する文字列１
	  #####<str2>	#比較する文字列２
	  値 ##述語が真ならば t#それ以外は nil
	##備考 大文字／小文字の違いは意味を持たない

string-not-lessp#<str1>#<str2>
	  組込関数 (p.408 lstring.p)
	  機能 文字列またはシンボルの比較
	  #####<str1>	#比較する文字列１
	  #####<str2>	#比較する文字列２
	  値 ##述語が真ならば t#それ以外は nil
	##備考 大文字／小文字の違いは意味を持たない

string-greaterp#<str1>#<str2>
	  組込関数 (p.408 lstring.p)
	  機能 文字列またはシンボルの比較
	  #####<str1>	#比較する文字列１
	  #####<str2>	#比較する文字列２
	  値 ##述語が真ならば t#それ以外は nil
	##備考 大文字／小文字の違いは意味を持たない

string-search#<str1>#<str2>
	  組込関数 (lstring.p)
	  機能 検索を行う
	  #####<str1>  検索文字列またはシンボル
	  #####<str2>##被検索文字列
	  値 ##検索文字列を発見したら、その位置を返し、見つからなかっ
	  #####たら、nil を返す
	  #####位置は文字を単位としています
	  備考 さらに高機能な検索には string-match#関数を使用します
	  例###(string-search#"abc" "0123abc789")###→ 4
	  #####(string-search#"abc" "0 １２ 3abc789")#→ 4
	  #####(string-search#"ab." "0 １２ 3abc789")#→ nil

string-to-list#<string>
	  組込関数 (lstring.p)
	  機能 文字列をリストに変換する
	  値 ##変換されたリスト
	  例###(string-to-list#"abc")
			#→ (#\a #\b #\c)
	  #####(string-to-list#" ＦＡＩ#")
			#→ (#\ Ｆ #\ Ａ #\ Ｉ )

list-to-string#<string>
	  組込関数 (lstring.p)
	  機能 リストを文字列に変換する
	  値 ##変換された文字列
	  例###(list-to-string#'(#\a #\b #\c))
			#→ "abc"
	  #####(list-to-string#'(#\ Ｆ #\ Ａ #\ Ｉ ))
			#→ " ＦＡＩ#"

make-string#<length> &optional#<char>
	  組込関数 (p.408 lstring.p)
	  機能 指定された長さの文字列を生成する
	  #####<length> 文字列の要素数
	  #####<char>	初期化文字（デフォルトは空白）
	  値 ##生成された文字列
	  備考 初期化文字が指定されなければ、空白 (#x20) で初期化し
	  #####ます。
	  例###(make-string#2 #\a)
	  #####→  #"aa"
	  #####(make-string#6 #\ あ )
	  #####→  #" ああああああ#"
	  #####(make-string#0)
	  #####→  #""

copy-string#<str>
	  組込関数 (lstring.p)
	  機能 引数と同じ文字列を新しく生成します
	  値 ##生成された文字列

strcat#<str> &rest#<str>
	  組込関数 (lstring.p)
	  機能 引数をつなげて文字列を新しく生成します
	  値 ##生成された文字列
	  例###(strcat#"123" "abc" "567")
			#→ #"123abc567"

substring#<str> &optional#<start>#<end>
	  組込関数 (lstring.p)
	  機能 引数の一部を取り出し、新たな文字列を生成します
	  #####<str>   元になる文字列
	  #####<start>#開始位置（零開始）
	  #####<end> ##終了位置（零開始）
	  備考 位置の指定が省略されると、零が指定されたものとみなし
	  #####ます。
	  #####終了位置が開始位置よりも前になる場合は終了位置は文字
	  #####列の最後になります。
	  値 ##生成された文字列あるいは nil
	##例###(substring#"0 １#2 ３ 4 ５#6 ７ 8 ９#")
	  #####→  "0 １#2 ３ 4 ５#6 ７ 8 ９#"
	  #####(substring#"0 １#2 ３ 4 ５#6 ７ 8 ９#"#2 5)
	  #####→  "2 ３ 4 ５#"
	  #####(substring#"0123456789"#2 0)
	  #####→  "23456789"
	  #####(substring#"0123456789"#12 0)
	  #####→  nil

string-trim#<character-bag>#<string>
	  組込関数 (p.409 lstring.p)
	  機能 文字列#<string> の両端からの部分削除
	  #####<character-bag>#削除する文字
	  #####<string> #削除される文字列
	  備考 新たな文字列を生成しますので、元の文字列は影響を受け
	  #####ません
	  #####削除する文字列に全角文字を指定することには対応してい
	  #####ないため、全角文字を指定すると正常に動作しないことが
	  #####あります
	  値 ##文字列#<string> の両端から削除文字列を除いたものを返
	  #####す
	  例###(string-trim##"#\t123"
		####"  11323 a123b32311  #")
			#→ #"a123b"

string-left-trim#<character-bag>#<string>
	  組込関数 (p.409 lstring.p)
	  機能 文字列の左端からの部分削除
	  #####<character-bag>#削除する文字
	  #####<string> #削除される文字列
	  備考 新たな文字列を生成しますので、元の文字列は影響を受け
	  #####ません
	  #####削除する文字列に全角文字を指定することには対応してい
	  #####ないため、全角文字を指定すると正常に動作しないことが
	  #####あります
	  値 ##文字列#<string> の左端から削除文字列を除いたものを返
	  #####す
	  例###(string-left-trim##"#\t123"
		####"  11323 a123b32311  #")
			#→ #"a123b32311  #"

string-right-trim#<character-bag>#<string>
	  組込関数 (p.409 lstring.p)
	  機能 文字列の右端からの部分削除
	  #####<character-bag>#削除する文字
	  #####<string> #削除される文字列
	  備考 新たな文字列を生成しますので、元の文字列は影響を受け
	  #####ません
	  #####削除する文字列に全角文字を指定することには対応してい
	  #####ないため、全角文字を指定すると正常に動作しないことが
	  #####あります
	  値 ##文字列#<string> の右端から削除文字列を除いたものを返
	  #####す
	  例###(string-right-trim##"#\t123"
		####"  11323 a123b32311  #")
			#→ #"  11323 a123b"

string-upcase#<str>
	  機能 文字列に含まれるアルファベットを大文字にする
	  備考 新たな文字列を生成しますので、元の文字列は影響を受け
	  #####ません
	  値 ##文字が置き換えられた文字列
	  例###(string-upcase#"123abcABC Ａａ#")
	  #####→ "123ABCABC Ａａ#"

string-downcase#<str>
	  機能 文字列に含まれるアルファベットを小文字にする
	  備考 新たな文字列を生成しますので、元の文字列は影響を受け
	  #####ません
	  値 ##文字が置き換えられた文字列
	  例###(string-downcase#"123abcABC Ａａ#")
	  #####→ "123abcabc Ａａ#"

string-capitalize#<str>
	  機能 文字列に含まれるアルファベット列の先頭を大文字に、残
	  #####りを小文字にする
	  備考 新たな文字列を生成しますので、元の文字列は影響を受け
	  #####ません
	  #####数字に続くアルファベットは小文字になります
	  #####全角文字に続くアルファベットは大文字になります
	  値 ##文字が置き換えられた文字列
	  例###(string-capitalize
	  #####"i dON't wanT to StUdY c++. --- 1992Sept ＠ f*l")
	  #####→ "I Don'T Want To Study C++. --- 1992sept ＠ F*L"

nstring-upcase#<str>
	  機能 文字列に含まれるアルファベットを大文字にする
	  備考 元の文字列が変更されます
	  値 ##文字が置き換えられた文字列
	  例###(nstring-upcase#"123abcABC Ａａ#")
	  #####→ "123ABCABC Ａａ#"

nstring-downcase#<str>
	  機能 文字列に含まれるアルファベットを小文字にする
	  備考 元の文字列が変更されます
	  値 ##文字が置き換えられた文字列
	  例###(nstring-downcase#"123abcABC Ａａ#")
	  #####→ "123abcabc Ａａ#"

nstring-capitalize#<str>
	  機能 文字列に含まれるアルファベット列の先頭を大文字に、残
	  #####りを小文字にする
	  備考 元の文字列が変更されます
	  #####数字に続くアルファベットは小文字になります
	  #####全角文字に続くアルファベットは大文字になります
	  値 ##文字が置き換えられた文字列
	  例###(nstring-capitalize
	  #####"i dON't wanT to StUdY c++. --- 1992Sept ＠ f*l")
	  #####→ "I Don'T Want To Study C++. --- 1992sept ＠ F*L"

string-jis-upcase#<str>
	  機能 文字列に含まれるアルファベット（２バイト文字）を大文
	  #####字にする
	  備考 新たな文字列を生成しますので、元の文字列は影響を受け
	  #####ません
	  値 ##文字が置き換えられた文字列
	  例###(nstring-jis-upcase#"123abcABC Ａａ#")
	  #####→ "123ABCABC ＡＡ#"

string-jis-downcase#<str>
	  機能 文字列に含まれるアルファベット（２バイト文字）を小文
	  #####字にする
	  備考 新たな文字列を生成しますので、元の文字列は影響を受け
	  #####ません
	  値 ##文字が置き換えられた文字列
	  例###(nstring-jis-downcase#"123abcABC Ａａ#")
	  #####→ "123abcabc ａａ#"

nstring-jis-upcase#<str>
	  機能 文字列に含まれるアルファベット（２バイト文字）を大文
	  #####字にする
	  備考 元の文字列が変更されます
	  値 ##文字が置き換えられた文字列
	  例###(nstring-jis-upcase#"123abcABC Ａａ#")
	  #####→ "123ABCABC ＡＡ#"

nstring-jis-downcase#<str>
	  機能 文字列に含まれるアルファベット（２バイト文字）を小文
	  #####字にする
	  備考 元の文字列が変更されます
	  値 ##文字が置き換えられた文字列
	  例###(nstring-jis-downcase#"123abcABC Ａａ#")
	  #####→ "123abcabc ａａ#"

string-jis-hira-to-kata#<str>
	  機能 文字列に含まれる平仮名（２バイト文字）を片仮名にする
	  備考 新たな文字列を生成しますので、元の文字列は影響を受け
	  #####ません
	  値 ##文字が置き換えられた文字列
	  例###(string-jis-hira-to-kana#"#あいうエオ#")
	  #####→ " アイウエオ#"

string-jis-kata-to-hira#<str>
	  機能 文字列に含まれる片仮名（２バイト文字）を平仮名にする
	  備考 新たな文字列を生成しますので、元の文字列は影響を受け
	  #####ません
	  値 ##文字が置き換えられた文字列
	  例###(string-jis-kata-to-hira#"#あいうエオ#")
	  #####→ " あいうえお "

nstring-jis-hira-to-kata#<str>
	  機能 文字列に含まれる平仮名（２バイト文字）を片仮名にする
	  備考 元の文字列が変更されます
	  値 ##文字が置き換えられた文字列
	  例###(string-jis-hira-to-kana#"#あいうエオ#")
	  #####→ " アイウエオ#"

nstring-jis-kata-to-hira#<str>
	  機能 文字列に含まれる片仮名（２バイト文字）を平仮名にする
	  備考 元の文字列が変更されます
	  値 ##文字が置き換えられた文字列
	  例###(string-jis-kata-to-hira#"#あいうエオ#")
	  #####→ " あいうえお "

re-set-syntax <flag>
	  組込関数 (lmatch.p)
	  機能 正規表現検索の文法を設定する
	  #####<flag> は以下の組み合わせによって指定する
		RE_NO_BK_PARENS####1
		RE_NO_BK_VBAR	  #2
		RE_BK_PLUS_QM	  #4
		RE_TIGHT_VBAR	  #8
		RE_NEWLINE_OR	  #16
		RE_CONTEXT_INDEP_OPS	32
		RE_AWK_CLASS_HACK  64
	  #####通常、以下のような組み合わせで使用します
		RE_SYNTAX_POSIX_EGREP	35
		RE_SYNTAX_AWK	  #99（AWK と同じ）
		RE_SYNTAX_EGREP####51（EGREP#と同じ）
		RE_SYNTAX_GREP		20（GREP#と同じ）
		RE_SYNTAX_EMACS####0 （EMACS#と同じ）
	  値 ##フラグ
	  例###(re-set-syntax 0)#→ 0
	  備考 初期状態のまま、指定を行わなければ、EMACS#同様の文法
	  #####となります。

string-match#<str1>#<str2> &optional <pos>
	  組込関数 (lmatch.p)
	  機能 正規表現検索を行う
	  #####<str1># 検索文字列またはシンボル
	  #####<str2>  被検索文字列またはシンボル
	  #####<pos> ##検索開始位置（零開始）
	  値 ##検索文字列を発見したら、その位置を返し、見つからなかっ
	  #####たら、nil を返す
	  #####位置は文字を単位としています
	  備考 この関数を実行すると、バイト単位での一致位置が
	  #####*reg-start-byte-position* に、一致終了位置 ( 一致した
	  #####部分の次の位置 ) が#*reg-end-byte-position* に設定さ
	  #####れます。
	  例###(string-match#"xxx" "kjhabc")	#→ nil
	  #####(string-match#"abc" "kjhabc")	#→ 3
	  #####(string-match#"[a-c].." "kjhabc")#→ 3
		  ##*reg-start-byte-position* #→ 3
		  ##*reg-end-byte-position* ###→ 6
	  #####(string-match#"[a-c].." "kjha あ c")#→ 3
		  ##*reg-start-byte-position* #→ 3
		  ##*reg-end-byte-position* ###→ 7
	  #####(string-match#"[a-c].." " い jha あ c")#→ 3
		  ##*reg-start-byte-position* #→ 4
		  ##*reg-end-byte-position* ###→ 8
	  #####(string-match#"[ あ - ん ]" " ＡＢＣをん ")#→ 3
		  ##*reg-start-byte-position* #→ 6
		  ##*reg-end-byte-position* ###→ 8
	  #####(string-match#"[ あ - ん ]" " ＡＢＣをん " 4)#→ 4
		  ##*reg-start-byte-position* #→ 8
		  ##*reg-end-byte-position* ###→ 10
	  #####(string-match#"[ あ - ん ]" "abc んＸ " 4)#→ nil
		  ##*reg-start-byte-position* #→ -1
		  ##*reg-end-byte-position* ###→ -1

match-string#<str1>#<str2> &optional <pos>
	  組込関数 (lmatch.p)
	  機能 正規表現検索を行う
	  #####string-match#関数と全く同じ
	  値 ##検索文字列を発見したら、その位置を返し、見つからなかっ
	  #####たら、nil を返す
	  #####位置は文字を単位としています
	  備考 この関数を実行すると、バイト単位での一致位置が
	  #####*reg-start-byte-position* に、一致終了位置 ( 一致した
	  #####部分の次の位置 ) が#*reg-end-byte-position* に設定さ
	  #####れます。
	  例###string-match#関数を参照して下さい


#####［第２０章  構造体］
#####--------------------


defstruct <name> (<slot>|{<slot>#<form>})
	  特殊形式 (larray.p p.415)
	  マクロ (init.lsp p.415)
	  機能 構造体を定義する
	  値 ##定義された構造体を返す
	  備考 マクロ定義では、構造体のコピー関数およびコンストラク
	  #####タ関数、アクセス関数が自動的に定義される。
	  例###(defstruct space-ship x y (z 0)) とすれば、自動的に関
	  #####数定義がなされて、(make-space-ship x 20 y 30)#により、
	  ######S(ship x 20 y 30 z 0) を生成することができる。
	  #####ここで ship を make-ship で作られた構造体とすれば、
	  #####(copy-space-ship ship)#により、ship のコピーを生成で
	  #####きる。
	  #####(space-ship-x ship)#により、構造体のスロット x の内容
	  #####を取り出すことができる。
	  #####(set-space-ship-x ship 5)#により、構造体 ship のスロッ
	  #####ト x の内容を変更することができる。

stref#<struct>#<slot>
	  組込関数 (larray.p)
	  機能 構造体のスロットの内容を取り出す
	  値 ##構造体のスロットの内容を返す
	  例###(setq a (make-forum name 'FAI mes 10))
	  #####(stref#'a 'name)#→ fai

set-struct <struct>#<slot> <content>
	  組込関数 (larray.p)
	  機能 構造体のスロットの内容を変更する
	  値 ##変更された構造体を返す
	  例###(setq a (make-forum name 'FPL mes 10))
	  #####(set-struct 'a 'name 'FAI)
	  #####→ #S(forum name fai mes 10)

make-struct <struct>#{<slot>#<cotent>}
	  組込関数 (larray.p)
	  機能 指定したスロット内容を持つ構造体を新たに生成する
	  値 ##生成された構造体を返す
	  例###(setq a (defstruct forum name mes))
	  #####(make-struct a mes 2)
	  #####→ #S(forum name nil mes 2)

copy-struct <struct>
	  組込関数 (larray.p)
	  機能 指定した構造体の複製を新たに生成する
	  値 ##生成された構造体を返す

struct-to-vector <struct>
	  組込関数 (larray.p)
	  機能 構造体をベクタに変換する
	  備考 構造体はベクタで表現されていますが、この関数では、新
	  #####たなベクタを生成しますので、もとの構造体と要素を共有
	  #####することはありません。
	  値 ##新たに生成されたベクタを返す

struct-to-list <struct>
	  組込関数 (larray.p)
	  機能 構造体をリストに変換する
	  値 ##生成されたリストを返す

struct-equal <array> <array>
	  組込関数 (larray.p)
	  機能 等しい構造体か？
	  値 ##等しければ t#等しくなければ nil


#####［第２０章  エバリュエーター］
#####------------------------------


eval <form>
	  組込関数 (p.432 leval.p)
	  機能 λογοσ式の評価
	  値 ##式の評価結果

constantp <form>
	  組込関数 (p.435 leval.p)
	  機能 定数か？
	  値 ##定数なら t#定数でなければ nil
	  備考 定数宣言されたシンボルおよびリスト以外の型であれば、
	  #####定数とみなします。


#####［第２１章  ストリーム］
#####------------------------


close <num>
	  組込関数 (lfile.p)
	  機能 ファイルハンドル（ストリーム）のクローズ
	  値 ##クローズできれば t#、できなければ nil
	  備考 異常な引数を与えると不都合が生じることがあります。


#####［第２２章  入出力］
#####--------------------


read &optional <stream>
	  組込関数 (p.502 lread.p)
	  機能 式の読み込み
	  値 ##読み込まれた式

read-line &optional <stream>
	  組込関数 (p.505 lread.p)
	  機能 改行によって終了される行の読み込み
	  値 ##読み込まれた行を文字列で返す
	  備考 コンソール入力時には、プロンプトや括弧の状況の表示は
	  #####消えます

read-char &optional <input-stream>
	  組込関数 (p.505 lread.p)
	  機能 １文字を入力し、文字型として返す
	  値 ##読み込まれた文字

unread-char <character>#<input-stream>
	  組込関数 (p.505 lread.p)
	  機能 １文字を入力に戻す
	  値 ##nil

peek-char &optional <input-stream>
	  組込関数 (p.505 lread.p)
	  機能 １文字を入力し、文字型として返す
	  #####ただし、入力の位置は更新しない
	  値 ##読み込まれた文字
	  備考 read-char の後、unread-char したのと同じ

clear-input	  ##組込関数 (p.507 lread.p)
	  機能 バッファのクリア
	  値 ##nil

read-from-string  <string>
	  組込関数 (p.507 lread.p)
	  機能 文字列をＳ式として読み込みます
	  値 ##読み込まれたＳ式
	  備考 最初のひとつめのＳ式のみ有効です
	  #####値はひとつしか返しません
	  例###(read-from-string "(a b c)")#→ (a b c)
	  #####(read-from-string "1 2 3 4")#→ 1

read-byte &optional <input-stream>
	  組込関数 (p.508 lread.p)
	  機能 １バイトを入力し、整数として返す
	  値 ##読み込まれた整数

getch
	  組込関数 (letc.p)
	  機能 コンソールからの１文字入力（エコーなし）
	  値 ##文字

kbhit
	  組込関数 (letc.p)
	  機能 キーが押されているか
	  値 ##押されていれば t#押されていなければ nil

prin1 <expr>
	  組込関数 (p.509 lprint.p)
	  機能 式のプリント
	  #####<expr>	 プリントする式
	  値 ##式 <expr> そのもの

print <expr>
	  組込関数 (p.509 lprint.p)
	  機能 次行に式をプリントする（印字後改行せず、空白を出力す
	  #####る）
	  値 ##式 <expr> そのもの

princ <expr>
	  組込関数 (p.509 lprint.p)
	  機能 #\ などの接頭詞抜きで式をプリントする
	  値 ##式 <expr> そのもの

write-char <chracter>#&optional <stream>
	  組込関数 (p.510 lprint.p)
	  機能 文字を #\ などの接頭詞抜きで出力する
	  値 ##与えられた文字。出力できなかった時は#nil

write-string <string>#&optional <stream>
	  組込関数 (p.510 lprint.p)
	  機能 文字列を引用符抜きで出力する
	  値 ##与えられた文字列。出力できなかった時は#nil

terpri	  #####組込関数 (p.511 lprint.p)
	  機能	現在のプリント行を終了する
	  値	nil

terpris <num>
	  組込関数 (lprint.p)
	  機能	引数回改行する
	  値	nil

space
	  組込関数 (lprint.p)
	  機能	空白を出力する
	  値	nil

spaces <num>
	  組込関数 (lprint.p)
	  機能	引数回空白を出力する
	  値	nil

tab
	  組込関数 (lprint.p)
	  機能	タブを出力する
	  値	nil

tabs <num>
	  組込関数 (lprint.p)
	  機能	引数回タブを出力する
	  値	nil

write-byte <number>#&optional <stream>
	  組込関数 (p.512 lprint.p)
	  機能 255 までの整数を１バイト出力する
	  値 ##与えられた整数。出力できなかった時は#nil


#####［第２３章  ファイルシステム・インターフェース］
#####------------------------------------------------


open <fname>#<options>
	  組込関数 (p.571 lfile.p)
	  機能 ファイルのオープン
	  #####<fname>	  ファイル名称を表す文字列又はシンボル
	  #####<options> ファイルのオープンモード
		  ##:input####入力モード
		  ##:output###出力モード
		  ##:io  入出力モード
		  ##:append###追加書き込みモード
		  ##:character
			 テキストモードに相当
		  ##:byte ####バイナリモードに相当
	  備考 準備されていないドライブを指定すると異常終了します
	  値 ##ファイルポインタ（整数）

with-open-file (<stream> <fname>#{options}) {body}
	  マクロ (p.576 init.lsp)
	  機能 ファイルのオープンし、本体を評価した後、ファイルをク
	  #####ローズします。
	  #####<stream> ファイルを束縛するシンボル
	  #####<fname>	  ファイル名称を表す文字列又はシンボル
	  #####<options> ファイルのオープンモード
		  ##:input####入力モード
		  ##:output###出力モード
		  ##:io  入出力モード
		  ##:append###追加書き込みモード
		  ##:character
			 テキストモードに相当
		  ##:byte ####バイナリモードに相当
	  #####<body>	 本体（暗黙の progn）
	  備考 準備されていないドライブを指定すると異常終了します
	  値 ##本体の返す値

load#<fname>
	  組込関数 (p.581 lfile.p)
	  機能 ソースファイルのロード
	  #####<fname>	 ファイル名称を表す文字列又はシンボル
	  値 ##t
	  #####準備されていないドライブを指定すると異常終了します
	  備考 *load-print* が#nil でなければ、ファイル中の内容を評
	  #####価した結果を表示し、*load-print* の内容を区切りとして
	  #####表示します。

seek <position>#<stream>
	  組込関数 (lfile.p)
	  機能 ファイルの読み書き位置を先頭から <position>#の所へ移
	  #####動する
	  #####準備されていないドライブを指定すると異常終了します
	  値 ##成功すれば t#失敗すれば nil

tell <position>#<stream>
	  組込関数 (lfile.p)
	  機能 ファイルの読み書き位置を求める
	  #####準備されていないドライブを指定すると異常終了します
	  値 ##現在の読み書き位置（整数）

delete-file <file>
	  組込関数 (p.578 file.p)
	  機能 ファイルの削除
	  #####<file>	 ファイル名
	  備考 ファイル名は文字列またはシンボルのどちらでも良い
	  #####準備されていないドライブを指定すると異常終了します
	  値 ##成功すればファイル名をそのまま返す。失敗すれば nil を
	  #####返す

probe-length <file>
	  組込関数 (p.579 lfile.p)
	  機能 ファイルが存在するか
	  #####<file>	 ファイル名称を表す文字列又はシンボル
	  #####準備されていないドライブを指定すると異常終了します
	  値 ##存在すれば t#なければ nil

file-length <file>
	  組込関数 (lfile.p)
	  機能 ファイルの大きさ
	  #####<file>	 ファイル名称を表す文字列又はシンボル
	  #####準備されていないドライブを指定すると異常終了します
	  値 ##ファイルのサイズを返す

change-dir <dir>
	  組込関数 (lfile.p)
	  機能 カレントディレクトリの変更
	  #####<dir>	 ディレクトリ名
	  備考 ディレクトリ名は文字列またはシンボルのどちらでも良い
	  #####準備されていないドライブを指定すると異常終了します
	  値 ##成功すればディレクトリ名をそのまま返す。失敗すれば nil
	  #####を返す

make-dir <dir>
	  組込関数 (lfile.p)
	  機能 ディレクトリの作成
	  #####<dir>	 ディレクトリ名
	  備考 ディレクトリ名は文字列またはシンボルのどちらでも良い
	  #####準備されていないドライブを指定すると異常終了します
	  値 ##成功すればディレクトリ名をそのまま返す。失敗すれば nil
	  #####を返す

remove-dir <dir>
	  組込関数 (lfile.p)
	  機能 ディレクトリの削除
	  #####<dir>	 ディレクトリ名
	  備考 ディレクトリ名は文字列またはシンボルのどちらでも良い
	  #####準備されていないドライブを指定すると異常終了します
	  値 ##成功すればディレクトリ名をそのまま返す。失敗すれば
		nil を返す


#####［第２４章  エラー］
#####--------------------


error <num>
	  組込関数 (logos.p)
	  機能 エラー番号 <num>#のエラーを発生する
	  値 ##返ってこない

warn <num>
	  組込関数 (logos.p)
	  機能 エラー番号 <num>#のエラーを発生する
	  値 ##エラー番号

deferror <num> <message>
	  ユーザー定義関数 (init.lsp)
	  機能 エラー番号 <num>#のエラーを定義する
	  値 ##エラー番号
	  備考 既に定義されている番号で定義しても無効です


#####［第２５章  さまざまな機能］
#####----------------------------


trace {function-name}
	  特殊形式 (p.616 letc.p)
	  機能 トレースを設定します
	  値 ##トレースされている関数のリスト
	  備考 *traced-functions* というシンボルアトムの値が常にトレー
	  #####スされている関数のリストになっています。
	  例###(trace car cdr cons list atom)

untrace {function-name}
	  特殊形式 (p.616 letc.p)
	  機能 トレースを解除します
	  #####引数が指定されない時は全てのトレースを解除します
	  値 ##トレースされている関数のリスト
	  備考 *traced-functions* というシンボルアトムの値が常にトレー
	  #####スされている関数のリストになっています。

time <flag>
	  組込関数 (p.617 letc.p)
	  機能 経過時間を求めます
	  値 ##引数が t#のとき、λογοσの内部時計をリセットし、そ
	  #####れまでの内部時計の経過時間を返します。
	  #####引数が nil のとき、単に現在のλογοσ内部時計の経過
	  #####時間を返します。
	  備考 コモンリスプとは仕様が全く違いますので、コモンリスプ
	  #####の time 関数は bench-mark-test などで代用して下さい。
	  #####なお、バ−ジョン 0.40 以降では、時間の表現形式が#0.01
	  #####秒単位の浮動少数点数になりました。（ただし、PC9801 で
	  #####は１秒以下は計測できないので無効です）

bench-mark-test <expr> <number>
	  組込関数 (p.617 letc.p)
	  機能 評価にかかった時間を求めます。
	  #####expr を number 回評価し、それに要した時間を求めます。
	  #####number が省略されたときには、１回だけの評価します。
	  例###(fib 10) を１０回評価したときの時間を求める
	  #####(bench-mark-test '(fib 10) 10)
	  備考 バ−ジョン 0.40 以降では、時間の表現形式が#0.01#秒単
	  #####位の浮動少数点数になりました。（ただし、PC9801 では１
	  #####秒以下は計測できないので無効です）

describe <object> &optional <stream>
	  組込関数 (p.617 letc.p)
	  機能 引数の情報を提供します。
	  値 ##情報があれば t#なければ nil
	  備考 引数はシンボルでなくてはなりません。
	  #####このマニュアル自身を参照して情報提供を行います。この
	  #####マニュアルにないものは無視されます。参照するマニュア
	  #####ルは *manual-file* の値を変えることで変更できます。

ed &optional <x>
	  ユーザー定義関数 (p.619 init.lsp)
	  機能 エディタ呼び出し
	  備考 引数は文字列またはシンボルでなくてはなりません。

room
	  組込関数 (p.619 letc.p)
	  機能 メモリーアロケーション情報の表示
	  値 ##nil

dribble &optional <filename>
	  組込関数 (p.619 lfile.p)
	  機能 入出力の記録
	  値 ##t#または nil
	  備考 引数がない場合には、記録を終了します
	  #####引数がある時は、新規に記録を開始します

codearea
	  組込関数 (letc.p)
	  機能 コンパイルコード領域の使用状況を取得する
	  値 ##コード領域の、先頭アドレス、使用中の位置、終端アドレ
	  #####スをリストにしたもの

cellarea
	  組込関数 (letc.p)
	  機能 コンス領域の使用状況を取得する
	  値 ##コンス領域の、先頭アドレス、使用中の位置、終端アドレ
	  #####スをリストにしたもの

arrayarea
	  組込関数 (letc.p)
	  機能 配列領域の使用状況を取得する
	  値 ##配列領域の、先頭アドレス、使用中の位置、終端アドレス
	  #####をリストにしたもの

structarea
	  組込関数 (letc.p)
	  機能 構造体領域の使用状況を取得する
	  値 ##構造体領域の、先頭アドレス、使用中の位置、終端アドレ
	  #####スをリストにしたもの

symbolarea
	  組込関数 (letc.p)
	  機能 シンボルアトム領域の使用状況を取得する
	  値 ##シンボルアトム領域の、先頭アドレス、使用中の位置、終
	  #####端アドレスをリストにしたもの

stringarea
	  組込関数 (letc.p)
	  機能 文字列領域の使用状況を取得する
	  値 ##文字列領域の、先頭アドレス、使用中の
	  #####位置、終端アドレスをリストにしたもの

floanumarea
	  組込関数 (letc.p)
	  機能 浮動小数点数領域の使用状況を取得する
	  値 ##浮動小数点数領域の、先頭アドレス、使用中の位置、終端
	  #####アドレスをリストにしたもの

get-decode-time 	 組込関数 (p.623 letc.p)
	  機能 実時間を求めます
	  値 ##秒、分、時、日、月、年を要素としたリストを返します
	  備考 週日、夏時間かどうか、タイムゾーンについては返されま
	  #####せん

sleep <secounds>
	  組込関数 (p.624 letc.p)
	  機能 指定された秒数の間、実行を停止します
	  値 ##nil

lisp-implementation-type
	  ユーザー定義関数 (p.625 init.lsp)
	  機能 処理系の名前を返します
	  値 ##処理系の名前（文字列）

lisp-implementation-version
	  ユーザー定義関数 (p.625 init.lsp)
	  機能 処理系のバージョンを返します
	  値 ##処理系のバージョン（文字列）

machine-type
	  ユーザー定義関数 (p.625 init.lsp)
	  機能 処理系の動く環境を返します
	  値 ##処理系の動く環境（文字列）

pc9801p
	  組込関数 (letc.p)
	  機能 ＰＣ９８０１か
	  値 ##ＰＣ９８０１なら t#そうでなければ nil
	  備考 ９８用 go32 のＨバージョン (djgpp98h) 以降の時のみ t
	  #####となります

fpup
	  組込関数 (letc.p)
	  機能 数値演算プロセッサが装備されているか
	  値 ##数値演算プロセッサがあれば t#そうでなければ nil
	  備考 環境文字列で emu が指定されているかどうかを調べます (
	  #####指定されていれば浮動小数点プロセッサがあるとみなして
	  #####nil)。エミュレータを載せないで浮動小数演算を行うと、
	  #####当然 fpup の値にかかわらずコプロセッサ不在 ( 割り込み
	  #####７ ) のエラーとなります。
	  #####数値演算プロセッサがある場合には、エミュレータ使用の
	  #####場合とは違う専用のルーチンで計算を行いますので、速度
	  #####が大幅に向上します。

memory
	  組込関数 (letc.p)
	  機能 コンベンショナルメモリの容量を求める
	  値 ##ＰＣ９８０１なら nil#そうでなければメモリサイズをＫバ
	  #####イト単位で返す

dosver
	  組込関数 (letc.p)
	  機能 ＤＯＳのバージョンを返す
	  値 ##ＤＯＳのバージョン（ドット対）

go32ver
	  組込関数 (letc.p)
	  機能 go32 のバージョンを返す
	  値 ##go32 バージョン（ドット対）
	  #####ただし、９８用 go32 のみで有効です

go32ver2
	  組込関数 (letc.p)
	  機能 go32 の差分バージョンを返す
	  値 ##go32 差分バージョン（ドット対）
	  #####ただし、９８用 go32 のみで有効です

identity <object>
	  組込関数 (p.626 letc.p)
	  機能 同定関数 ( 何もしない )
	  値 ##<object>

system <string>
	  組込関数 (letc.p)
	  機能 子プロセスを起動します
	  値 ##子プロセスから返された数値（リターン
	  #####コード）
	  備考 エスケープ文字が "\" であるので、go32 上でのディレク
	  #####トリの表現のためには "\" を２回重ねるか、"/" を使うこ
	  #####とが必要です。DOS 上のソフトへ渡す引数にディレクトリ
	  #####表現がある場合は、必ず "\" を重ねて下さい（"/" ではエ
	  #####ラーです）。
	  例###(system "vz @")
	   ####(system "a:\\mifes\\mifes")
	   ####(system "a:/mifes/mifes")
	   ####(system "b:\\command")
	   ####(system "b:/command")
	   ####(system "dir c:\\logos\\go32")
	   ####(system "a:/dos3/symdeb b:\\logos\\go32\\a.out")
	   ####(system "go32 logos.out")

getenv <string>
	  組込関数 (letc.p)
	  機能 環境変数を参照します
	  値 ##環境変数の値を文字列にして返す
	  備考 環境変数は大文字でも小文字でも参照できます
	  例###(getenv "Go32")
	   ####→ "emu A:/djgcc/emu387/emu387 fast"

peek <addrs>
	  組込関数 (letc.p)
	  機能 メモリー内容の読み出し（１バイト）
	  値 ##該当アドレスの値
	  備考 取得されていないメモリ領域をアクセスすると異常終了し
	  #####ます

dpeek <addrs>
	  組込関数 (letc.p)
	  機能 メモリー内容の読み出し（２バイト）
	  値 ##該当アドレスの値
	  備考 取得されていないメモリ領域をアクセスすると異常終了し
	  #####ます

peek* <byte> <addrs>
	  組込関数 (letc.p)
	  機能 メモリー内容の読み出し（１バイト）
	   ####<byte>	 リニアアドレスの先頭１バイト
	   ####<addrs>	 リニアアドレスの残り３バイト
	  値 ##該当アドレスの値
	  備考 (peek* 0 #x1234567) は (peek #x1234567) と同じです
	  #####例えば、#xe0000000 以降にコンベンショナルメモリがマッ
	  #####ピングされている時には、(peek* #xe address) とすれば、
	  #####コンベンショナルメモリの内容にアクセスできます。
	  #####取得されていないメモリ領域をアクセスすると異常終了し
	  #####ます

poke <addrs> <value>
	  組込関数 (letc.p)
	  機能 メモリーへの書き込み（１バイト）
	  値 ##値
	  備考 取得されていないメモリ領域をアクセスすると異常終了し
	  #####ます

dpoke <addrs> <value>
	  組込関数 (letc.p)
	  機能 メモリーへの書き込み（２バイト）
	  値 ##値
	  備考 取得されていないメモリ領域をアクセスすると異常終了し
	  #####ます

poke* <byte> <addrs>
	  組込関数 (letc.p)
	  機能 メモリー内容の書き込み（１バイト）
	   ####<byte>	 リニアアドレスの先頭１バイト
	   ####<addrs>	 リニアアドレスの残り３バイト
	  値 ##値
	  備考 (poke* 0 #x1234567 1) は (peek #x1234567 1) と同じで
	  #####す
	  #####例えば、#xe0000000 以降にコンベンショナルメモリがマッ
	  #####ピングされている時には、(poke* #xe address data) とす
	  #####れば、コンベンショナルメモリの内容にアクセスできます。
	  #####取得されていないメモリ領域をアクセスすると異常終了し
	  #####ます

poke-code <value>
	  組込関数 (letc.p)
	  機能 コード領域へのメモリーへの書き込み（１バイト）
	  #####コード領域の現在位置は１増加します
	  値 ##書き込まれたアドレス

address-of <data>
	  組込関数 (letc.p)
	  機能 実アドレスの取得
	  値 ##アトム領域上の位置

cell <num>
	  組込関数 (letc.p)
	  機能 アドレス <num> にあるセルの内容を求める
	  値 ##アドレスに位置するリストを返す。
	  #####アドレスが４の倍数でないとき、値は保証されない。
	  備考 アドレスがコンス領域の外にある場合には、エラーになる。

stack
	  組込関数 (letc.p)
	  機能 スタック内容の表示
	  値 ##nil
	  備考 ソフトウェアスタックの内容を現在のスタックポインタの
	  #####位置から、スタックの底まで表示します。デバッグ用です。
	  例###(prog (x y) (+ i u))
	   ####※ 引数は整数型か浮動小数点型でなくてはなりません。
	  #####(Error at +) unk
	   ####<0>》#(stack)
	   ####00449334 ((+ i u))  ;prog が実行する式
	   ####00000003   ####; 束縛終了の印 -------*
	   ####B0000000 unk	  #; プログ変数 y の現在値 |
	   ####3040DFED y	  #; プログ変数 y	 |
	   ####B0000000 unk	  #; プログ変数 x の現在値 |
	   ####3040D9C3 x	  #; プログ変数 x	 |
	   ####00000002   ####; 束縛開始の印 -------*
	   ####00000001   ####; ブロックの開始の印
	   ####10000000 nil	  #; ブロック名#(prog の場合は#nil)
	   ####7FFFFDDC   ####; ハードウェアスタック (%esp) の参照位
	  #####置
	   ####nil	  ####; 返り値は#nil

inp <addrs>
	  組込関数 (letc.p)
	  機能 ポートからの読み込み
	  値 ##値

outp <addrs> <value>
	  組込関数 (letc.p)
	  機能 ポートへの書き込み（１バイト）
	  値 ##値

redo <num>
	  組込関数 (letc.p)
	  機能 ヒストリ機能
	  #####コンソールからの過去の入力を取り出す
	  備考 redo 関数そのものの入力は記録されません。(redo) を除
	  #####く過去の入力はシンボルアトム *redo-list* に記録されま
	  #####す。
	  値 ##<num> 回前の入力を返す
	  例###<0>》#6
	   ####6
	   ####<0>》#7
	   ####7
	   ####<0>》#8
	   ####8
	   ####<0>》#*redo-list*
	  #####(*redo-list* 8 7 6)
	   ####<0>》#(redo 1)
	   ####8

top-level
	  組込関数 (letc.p)
	  機能 トップレベルへの復帰
	  値 ##帰ってこない
	  備考 ソフトウェアスタックと入力バッファを初期化します
	  #####この関数を実行しなければ、エラーが起きた後も、ソフト
	  #####ウェアスタックの状況は初期化されずに stack 関数で辿る
	  #####ことができますが、この関数を実行すると、ソフトウェア
	  #####スタックを開放してしまいますので、stack 関数によって
	  #####処理状況を把握できないことになります。

quit <num>
	  組込関数 (letc.p)
	  機能 λογοσを終了する
	  値 ##帰ってこない
	  備考 親プロセスには引数をリターンコードとして渡します。
	   ####quit,bye,si:logout は機能は全く同じですが、NIFTY の人
	  #####工知能フォーラム（ＦＡＩ）の FAI-LISP の会議室 (1)#
	   ####364-365 小林栄さんと NTAI さんの発言により付けました。

bye <num>
	  組込関数 (letc.p)
	  機能 λογοσを終了する
	  値 ##帰ってこない
	  備考 親プロセスには引数をリターンコードとして渡します。
	   ####quit,bye,si:logout は機能は全く同じですが、NIFTY の人
	  #####工知能フォーラム（ＦＡＩ）の FAI-LISP の会議室 (1)
	  ######364-365 小林栄さんと NTAI さんの発言により付けました。

si:logout <num>
	  組込関数 (letc.p)
	  機能 λογοσを終了する
	  値 ##帰ってこない
	  備考 親プロセスには引数をリターンコードとして渡します。
	   ####quit,bye,si:logout は機能は全く同じですが、NIFTY の人
	  #####工知能フォーラム（ＦＡＩ）の FAI-LISP の会議室 (1)#
	   ####364-365 小林栄さんと NTAI さんの発言により付けました。

exit <num>
	  組込関数 (letc.p)
	  機能 λογοσを終了する
	  値 ##帰ってこない
	  備考 親プロセスには引数をリターンコードとして渡します。
	   ####quit,bye,si:logout は機能は全く同じですが、NIFTY の人
	  #####工知能フォーラム（ＦＡＩ）の FAI-LISP の会議室 (1)#
	   ####364-365 小林栄さんと NTAI さんの発言により付けました。

gc
	  組込関数 (lgbc.p)
	  機能 ガーベッジコレクターの起動
	  値 ##空きセルの数（セル単位）

gbc
	  組込関数 (lgbc.p)
	  機能 ガーベッジコレクターの起動
	  値 ##空きセルの数（セル単位）

reclaim
	  組込関数 (lgbc.p)
	  機能 ガーベッジコレクターの起動
	  値 ##空きセルの数（セル単位）

expand <type> <size>
	  組込関数 (lexpnad.p)
	  機能 メモリの拡張
	   ####<type> cons array floanum string
	  #####<size> 確保するバイト数
	  #####第２引数が#nil の場合には、現在の倍のサイズを確保しま
	  #####す。
	  値 ##確保できた場合はサイズ（バイト単位）、できなかった場
	  #####合は#nil を返します。
	   ####現在割り付けられているメモリよりも小さいサイズが指定
	  #####されると、割り付けを行わずに nil を返します。
	  備考 シンボル領域とコンパイルコードの領域は拡張できません。
	  #####指定されたサイズの下位１バイトを切り上げます。
	   ####なお、セル１個は８バイトからなります。
	   ####関数名は将来的に変更する可能性があります。
	  例###(expand 'array #x20000) → 131072
	  #####(expand 'cons 2097157)  → 2097168

screen <mode> <num> <num>
	  組込関数 (lgraphic.p)
	  機能 画面モードの設定
	  備考 ＰＣ９８０１以外の機種の場合、機械の状況によっては、
	  #####グラフィックモードの設定を行う時にハングする可能性が
	  #####あります。ご了承のうえ、お使い下さい。
	   ####グラフィックの処理については djgcc のライブラリを利用
	  #####しています。
	  #####作者のＩＢＭ互換機（ＤＯＳ／Ｖ、ET4000 使用）では、通
	  #####常の２５行８０文字の状況からλογοσを起動した後、
	  #####(screen 7) で８００×６００ドットのモードになります。
	  #####(screen 1) で元に戻ります。

line <x1> <y1> <x2> <y2> <color>
	  組込関数 (lgraphic.p)
	  機能 画面に線を引く
	   ####<x1> 横方向の始点
	   ####<y1> 縦方向の始点
	   ####<x2> 横方向の終点
	   ####<y2> 縦方向の終点
	   ####<color> 色
	  値 ##nil

gclr <color>
	  組込関数 (lgraphic.p)
	  機能 グラフィック画面の消去
	   ####画面を塗り潰す色
	  値 ##nil

plot <x> <y> <color>
	  組込関数 (lgraphic.p)
	  機能 画面に点を打つ
	   ####<x> 横方向の座標
	   ####<y> 縦方向の座標
	   ####<color> 色
	  値 ##nil

circle <x> <y> <r> <color>
	  組込関数 (lgraphic.p)
	  機能 画面に円を書く
	   ####<x> 横方向の中心座標
	   ####<y> 縦方向の中心座標
	   ####<r> 半径
	   ####<color> 色
	  値 ##nil

poly <x> <y> <rx> <ry> <color>
	  組込関数 (lgraphic.p)
	  機能 画面に楕円を書く
	   ####<x> 横方向の中心座標
	   ####<y> 縦方向の中心座標
	   ####<rx> 横方向の径
	   ####<ry> 縦方向の径
	   ####<color> 色
	  値 ##nil

pixel <x> <y>
	  組込関数 (lgraphic.p)
	  機能 画面上の座標の色を返す
	   ####<x> 横方向の中心座標
	   ####<y> 縦方向の中心座標
	  値 ##色（整数）


			  ##+----------+
			  ##! おわりに !
			  ##+----------+


##まだまだ至らぬ処理系ですが、なんとか形になったのは、ＮＩＦＴＹのＦ
ＡＩとＦＰＬの皆様から会議室やＲＴで色々とご指導を戴いたおかげです。
心よりあつくお礼申し上げます。


				  ###PFE02147 澤田高宏／《ぬえ》
#
